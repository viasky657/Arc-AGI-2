{
    "instance_id": "java__book-store",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/src/main/java/BookStore.java b/src/main/java/BookStore.java\nindex f0f2e09..32d0a09 100644\n--- a/src/main/java/BookStore.java\n+++ b/src/main/java/BookStore.java\n@@ -1,9 +1,109 @@\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n \n class BookStore {\n \n-    double calculateBasketCost(List<Integer> books) {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n+    // Prices for each group size\n+    private static final double BOOK_PRICE = 8.0;\n+    private static final Map<Integer, Double> DISCOUNT_MAP = new HashMap<>();\n+    static {\n+        DISCOUNT_MAP.put(1, 1.0);\n+        DISCOUNT_MAP.put(2, 0.95);\n+        DISCOUNT_MAP.put(3, 0.90);\n+        DISCOUNT_MAP.put(4, 0.80);\n+        DISCOUNT_MAP.put(5, 0.75);\n     }\n \n-}\n\\ No newline at end of file\n+    public double calculateBasketCost(List<Integer> books) {\n+        // Assuming books.size() gives the number of different titles (should be 5 for this problem)\n+        // And each element is the count of that book in the basket.\n+        // We'll use a recursive approach with memoization.\n+        // Convert List<Integer> to int[] for easier manipulation.\n+        int n = books.size();\n+        int[] counts = new int[n];\n+        for (int i = 0; i < n; i++) {\n+            counts[i] = books.get(i);\n+        }\n+        Map<String, Double> memo = new HashMap<>();\n+        return Math.round(recursiveCost(counts, memo) * 100.0) / 100.0;\n+    }\n+\n+    private double recursiveCost(int[] counts, Map<String, Double> memo) {\n+        String key = buildKey(counts);\n+        if (memo.containsKey(key)) {\n+            return memo.get(key);\n+        }\n+\n+        // Check if basket is empty\n+        boolean empty = true;\n+        for (int count : counts) {\n+            if (count > 0) {\n+                empty = false;\n+                break;\n+            }\n+        }\n+        if (empty) {\n+            return 0;\n+        }\n+\n+        double best = Double.MAX_VALUE;\n+        int n = counts.length;\n+        // Iterate over all possible subsets of books\n+        // We will use bitmask approach for indices 0..n-1\n+        // Only consider non-empty subset, and only include books that are available (count > 0)\n+        int totalSubsets = 1 << n; // 2^n\n+\n+        for (int mask = 1; mask < totalSubsets; mask++) {\n+            // Check if mask is valid: each bit chosen must have count > 0\n+            boolean valid = true;\n+            int setSize = 0;\n+            for (int i = 0; i < n; i++) {\n+                if ((mask & (1 << i)) != 0) {\n+                    if (counts[i] <= 0) {\n+                        valid = false;\n+                        break;\n+                    }\n+                    setSize++;\n+                }\n+            }\n+            if (!valid) continue;\n+\n+            // Compute price for this group\n+            double discount = DISCOUNT_MAP.get(setSize);\n+            double groupPrice = setSize * BOOK_PRICE * discount;\n+\n+            // Create new state\n+            int[] newCounts = counts.clone();\n+            for (int i = 0; i < n; i++) {\n+                if ((mask & (1 << i)) != 0) {\n+                    newCounts[i] -= 1;\n+                }\n+            }\n+\n+            double cost = groupPrice + recursiveCost(newCounts, memo);\n+            if (cost < best) {\n+                best = cost;\n+            }\n+        }\n+        memo.put(key, best);\n+        return best;\n+    }\n+\n+    private String buildKey(int[] counts) {\n+        StringBuilder sb = new StringBuilder();\n+        for (int count : counts) {\n+            sb.append(count).append(\",\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    // A simple main to test the implementation\n+    public static void main(String[] args) {\n+        BookStore store = new BookStore();\n+        // Test example: 2 copies of the first 3 books, 1 copy of the last 2 books.\n+        // Representing basket as [2,2,2,1,1]\n+        double cost = store.calculateBasketCost(List.of(2,2,2,1,1));\n+        System.out.println(\"Total cost: $\" + cost);\n+    }\n+}\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}