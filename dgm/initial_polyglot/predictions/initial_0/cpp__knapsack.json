{
    "instance_id": "cpp__knapsack",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/knapsack.cpp b/knapsack.cpp\nindex 6e213bb..21e93d9 100644\n--- a/knapsack.cpp\n+++ b/knapsack.cpp\n@@ -1,7 +1,23 @@\n #include \"knapsack.h\"\n+#include <vector>\n+#include <algorithm>\n \n namespace knapsack\n {\n \n-} // namespace knapsack\n+int solveKnapsack(const std::vector<Item>& items, int capacity) {\n+    // dp[w] will hold maximum value for weight w\n+    std::vector<int> dp(capacity + 1, 0);\n+    \n+    // loop over each item, update dp in reverse order\n+    for (const auto& item : items) {\n+        // iterate backwards to ensure one item can only be picked once\n+        for (int w = capacity; w >= item.weight; --w) {\n+            dp[w] = std::max(dp[w], dp[w - item.weight] + item.value);\n+        }\n+    }\n+    \n+    return dp[capacity];\n+}\n \n+} // namespace knapsack\ndiff --git a/knapsack.h b/knapsack.h\nindex 19f4f0d..5a49274 100644\n--- a/knapsack.h\n+++ b/knapsack.h\n@@ -1,6 +1,8 @@\n #ifndef KNAPSACK_H\n #define KNAPSACK_H\n \n+#include <vector>\n+\n namespace knapsack\n {\n \n@@ -10,6 +12,9 @@ struct Item\n     int value;\n };\n \n+// Solves the 0/1 knapsack problem and returns the maximum total value that fits in the given capacity.\n+int solveKnapsack(const std::vector<Item>& items, int capacity);\n+\n } // namespace knapsack\n \n #endif // KNAPSACK_H\ndiff --git a/test/tests-main.cpp b/test/tests-main.cpp\nindex 0c7c351..018c1da 100644\n--- a/test/tests-main.cpp\n+++ b/test/tests-main.cpp\n@@ -1,2 +1,46 @@\n #define CATCH_CONFIG_MAIN\n #include \"catch.hpp\"\n+#include <vector>\n+#include \"knapsack.h\"\n+\n+TEST_CASE(\"Knapsack Example Test\") {\n+    // Items: [ {5,10}, {4,40}, {6,30}, {4,50} ]\n+    // Capacity: 10\n+    // Expected max value: 90 (taking items {4,40} and {4,50})\n+    std::vector<knapsack::Item> items = {\n+        {5, 10},\n+        {4, 40},\n+        {6, 30},\n+        {4, 50}\n+    };\n+    int capacity = 10;\n+    int maxValue = knapsack::solveKnapsack(items, capacity);\n+    REQUIRE(maxValue == 90);\n+}\n+\n+// Additional tests can be added here\n+\n+TEST_CASE(\"Knapsack Empty Items\") {\n+    std::vector<knapsack::Item> items;\n+    int capacity = 10;\n+    int maxValue = knapsack::solveKnapsack(items, capacity);\n+    REQUIRE(maxValue == 0);\n+}\n+\n+TEST_CASE(\"Knapsack Zero Capacity\") {\n+    std::vector<knapsack::Item> items = {\n+        {1, 100}\n+    };\n+    int capacity = 0;\n+    int maxValue = knapsack::solveKnapsack(items, capacity);\n+    REQUIRE(maxValue == 0);\n+}\n+\n+TEST_CASE(\"Knapsack Single Item Exceeding Capacity\") {\n+    std::vector<knapsack::Item> items = {\n+        {20, 100}\n+    };\n+    int capacity = 10;\n+    int maxValue = knapsack::solveKnapsack(items, capacity);\n+    REQUIRE(maxValue == 0);\n+}\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}