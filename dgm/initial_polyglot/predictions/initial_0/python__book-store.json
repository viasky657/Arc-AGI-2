{
    "instance_id": "python__book-store",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/book_store.py b/book_store.py\nindex 8a84288..f875f51 100644\n--- a/book_store.py\n+++ b/book_store.py\n@@ -1,2 +1,72 @@\n def total(basket):\n-    pass\n+    \"\"\"\n+    Calculate the total price for a basket of books with discounts applied.\n+    basket: list of integers representing book IDs (1 to 5) \n+    Each book costs $8. Discounts are applied when buying different books:\n+      2 different: 5%% discount\n+      3 different: 10%% discount\n+      4 different: 20%% discount\n+      5 different: 25%% discount\n+\n+    The strategy is to group the books into sets of unique books in a way that minimizes cost.\n+    \n+    For example, consider basket containing:\n+      2 copies of book 1\n+      2 copies of book 2\n+      2 copies of book 3\n+      1 copy of book 4\n+      1 copy of book 5\n+    A greedy grouping might form a group of 5 and a group of 3, but it is optimal to form two groups of 4.\n+    \n+    Returns:\n+      Total price as a float rounded to 2 decimals.\n+    \"\"\"\n+    # Price per book\n+    price_per_book = 8\n+    # Discount mapping for group sizes\n+    discounts = {1: 0, 2: 0.05, 3: 0.10, 4: 0.20, 5: 0.25}\n+    \n+    # Count the number of each book (books are numbered 1 to 5)\n+    counts = [0] * 5\n+    for book in basket:\n+        # Assuming book is between 1 and 5\n+        if 1 <= book <= 5:\n+            counts[book - 1] += 1\n+        else:\n+            raise ValueError(f\"Invalid book id {book}. Must be between 1 and 5.\")\n+    \n+    groups = []\n+    # Greedy grouping: while there is any book remaining, form a group\n+    while any(count > 0 for count in counts):\n+        group_size = 0\n+        for i in range(5):\n+            if counts[i] > 0:\n+                counts[i] -= 1\n+                group_size += 1\n+        groups.append(group_size)\n+        \n+    # Adjustment: When there is a group of 5 and a group of 3, replacing them by two groups of 4 reduces the price.\n+    # This is a known optimization in the Potter Kata.\n+    groups.sort(reverse=True)  # sort descending for convenience\n+    while 5 in groups and 3 in groups:\n+        groups.remove(5)\n+        groups.remove(3)\n+        groups.append(4)\n+        groups.append(4)\n+        groups.sort(reverse=True)\n+    \n+    total_price = 0\n+    for group in groups:\n+        discount = discounts[group]\n+        group_price = group * price_per_book * (1 - discount)\n+        total_price += group_price\n+    \n+    return round(total_price, 2)\n+\n+\n+if __name__ == '__main__':\n+    # Example test\n+    # Basket: [1,1,2,2,3,3,4,5] corresponds to:\n+    # 2 copies of book 1, 2 copies of book 2, 2 copies of book 3, 1 copy of book 4, 1 copy of book 5\n+    basket = [1, 1, 2, 2, 3, 3, 4, 5]\n+    print(f\"Total price: ${total(basket)}\")\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}