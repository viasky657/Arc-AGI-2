{
    "instance_id": "javascript__queen-attack",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/queen-attack.js b/queen-attack.js\nindex 16f26a8..e16a3cb 100644\n--- a/queen-attack.js\n+++ b/queen-attack.js\n@@ -1,21 +1,85 @@\n-//\n-// This is only a SKELETON file for the 'Queen Attack' exercise. It's been provided as a\n-// convenience to get you started writing code faster.\n-//\n+/*\n+ * Queen Attack Exercise\n+ * \n+ * A queen must be placed on a valid position on the board.\n+ * Two queens cannot share the same position.\n+ * \n+ * If a position has not been given, the queens are at their default starting positions:\n+ *   white: bottom row (row 1 -> index 0) at the fourth column (d -> index 3)\n+ *   black: top row (row 8 -> index 7) at the fourth column (d -> index 3)\n+ * \n+ * The chessboard is represented as an 8x8 matrix. Rows are numbered 1-8 starting from the bottom,\n+ * and columns a-h, with a mapping to zero-indexed array positions as follows:\n+ *   row index 0 corresponds to rank 1 (bottom row) and row index 7 corresponds to rank 8 (top row).\n+ *   column index 0 corresponds to file a and column index 7 corresponds to file h.\n+ * \n+ * The queen can attack if the opponent is in the same row, column, or diagonal.\n+ */\n \n export class QueenAttack {\n   constructor({\n-    black: [blackRow, blackColumn] = [],\n-    white: [whiteRow, whiteColumn] = [],\n+    black: blackPos = [],\n+    white: whitePos = []\n   } = {}) {\n-    throw new Error('Remove this statement and implement this function');\n+    // Set default positions if not provided\n+    // white queen: [0,3] and black queen: [7,3]\n+    this.white = (whitePos.length === 2) ? whitePos : [0, 3];\n+    this.black = (blackPos.length === 2) ? blackPos : [7, 3];\n+\n+    // Validate board boundaries\n+    const isValidPosition = ([row, col]) => {\n+      return row >= 0 && row <= 7 && col >= 0 && col <= 7;\n+    };\n+    if (!isValidPosition(this.white) || !isValidPosition(this.black)) {\n+      throw new Error('QueenAttack: Invalid queen position');\n+    }\n+\n+    // Check for same position\n+    if (this.white[0] === this.black[0] && this.white[1] === this.black[1]) {\n+      throw new Error('Queens cannot share the same space');\n+    }\n   }\n \n   toString() {\n-    throw new Error('Remove this statement and implement this function');\n+    // Build an 8x8 board initialized with '_'\n+    const size = 8;\n+    const board = Array.from({ length: size }, () => Array(size).fill('_'));\n+\n+    // Place the queens\n+    // white queen and black queen positions are [row, col]\n+    const [wRow, wCol] = this.white;\n+    const [bRow, bCol] = this.black;\n+    board[wRow][wCol] = 'W';\n+    board[bRow][bCol] = 'B';\n+\n+    // Build the string representation\n+    // The top label\n+    const files = 'a b c d e f g h';\n+    let output = `  ${files}\\n`;\n+    \n+    // Rows are displayed from top (row index 7 -> rank 8) to bottom (row index 0 -> rank 1)\n+    for (let row = size - 1; row >= 0; row--) {\n+      // Chess rank is row + 1, but printed as 8 at index 7 down to 1 at index 0\n+      const rank = row + 1;\n+      output += `${rank} ${board[row].join(' ')} ${rank}\\n`;\n+    }\n+\n+    // Bottom label\n+    output += `  ${files}`;\n+\n+    return output;\n   }\n \n   get canAttack() {\n-    throw new Error('Remove this statement and implement this function');\n+    const [wRow, wCol] = this.white;\n+    const [bRow, bCol] = this.black;\n+\n+    // Same row?\n+    if (wRow === bRow) return true;\n+    // Same column?\n+    if (wCol === bCol) return true;\n+    // Same diagonal? (difference between rows equals difference between columns)\n+    if (Math.abs(wRow - bRow) === Math.abs(wCol - bCol)) return true;\n+    return false;\n   }\n }\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}