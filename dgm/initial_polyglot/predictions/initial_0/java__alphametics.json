{
    "instance_id": "java__alphametics",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/src/main/java/Alphametics.java b/src/main/java/Alphametics.java\nindex 1ac637d..181802a 100644\n--- a/src/main/java/Alphametics.java\n+++ b/src/main/java/Alphametics.java\n@@ -1,13 +1,132 @@\n-import java.util.Map;\n+import java.util.*;\n+import java.util.stream.Collectors;\n \n-class Alphametics {\n+public class Alphametics {\n \n-    Alphametics(String userInput) {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n+    private String puzzle;\n+    private List<String> leftWords;\n+    private String resultWord;\n+    private Set<Character> letters;\n+    private Set<Character> leading;\n+\n+    public Alphametics(String userInput) {\n+        // Remove spaces around the puzzle and normalize input\n+        this.puzzle = userInput.trim();\n+        // Expecting a puzzle in the format: WORD [+ WORD ...] = WORD\n+        String[] parts = this.puzzle.split(\"=\");\n+        if (parts.length != 2) {\n+            throw new IllegalArgumentException(\"Puzzle must contain one '=' sign separating the sum and the result.\");\n+        }\n+\n+        // Parse left side and right side\n+        String leftPart = parts[0].trim();\n+        this.resultWord = parts[1].trim();\n+        if(this.resultWord.isEmpty()) {\n+            throw new IllegalArgumentException(\"Right-hand side (result) cannot be empty.\");\n+        }\n+\n+        // Split left-hand side words by '+' sign\n+        this.leftWords = Arrays.stream(leftPart.split(\"\\+\")).map(String::trim).collect(Collectors.toList());\n+        if(this.leftWords.isEmpty()) {\n+            throw new IllegalArgumentException(\"Left-hand side must contain at least one word.\");\n+        }\n+\n+        // Identify all unique letters and those that cannot be zero (leading letters)\n+        this.letters = new HashSet<>();\n+        this.leading = new HashSet<>();\n+\n+        for (String word : leftWords) {\n+            if (!word.isEmpty()) {\n+                leading.add(word.charAt(0));\n+            }\n+            for (char c : word.toCharArray()) {\n+                if (Character.isLetter(c)) {\n+                    letters.add(c);\n+                }\n+            }\n+        }\n+        // Process the result word\n+        leading.add(resultWord.charAt(0));\n+        for (char c : resultWord.toCharArray()) {\n+            if (Character.isLetter(c)) {\n+                letters.add(c);\n+            }\n+        }\n+\n+        if (letters.size() > 10) {\n+            throw new IllegalArgumentException(\"Too many unique letters; cannot map to digits 0-9.\");\n+        }\n+    }\n+\n+    public Map<Character, Integer> solve() throws UnsolvablePuzzleException {\n+        List<Character> letterList = new ArrayList<>(letters);\n+        Map<Character, Integer> assignment = new HashMap<>();\n+        if (solveRec(letterList, 0, assignment)) {\n+            return assignment;\n+        } else {\n+            throw new UnsolvablePuzzleException(\"Puzzle cannot be solved.\");\n+        }\n+    }\n+\n+    private boolean solveRec(List<Character> letterList, int index, Map<Character, Integer> assignment) {\n+        if (index == letterList.size()) {\n+            // All letters assigned; check if the puzzle holds\n+            long leftSum = 0;\n+            for (String word : leftWords) {\n+                long val = wordToNumber(word, assignment);\n+                if (val < 0) return false; // invalid conversion, although shouldn't happen\n+                leftSum += val;\n+            }\n+            long rightVal = wordToNumber(resultWord, assignment);\n+            return leftSum == rightVal;\n+        }\n+\n+        // Try all digits for the current letter\n+        char letter = letterList.get(index);\n+        for (int d = 0; d <= 9; d++) {\n+            if (assignment.containsValue(d)) continue; // digit already used\n+            // A leading letter cannot be 0\n+            if (d == 0 && leading.contains(letter)) continue;\n+            assignment.put(letter, d);\n+            if (solveRec(letterList, index + 1, assignment)) {\n+                return true;\n+            }\n+            assignment.remove(letter);\n+        }\n+        return false;\n     }\n \n-    Map<Character, Integer> solve() throws UnsolvablePuzzleException {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n+    private long wordToNumber(String word, Map<Character, Integer> assignment) {\n+        long num = 0;\n+        for (char c : word.toCharArray()) {\n+            Integer digit = assignment.get(c);\n+            if (digit == null) {\n+                return -1; // Should not happen if all letters are assigned\n+            }\n+            num = num * 10 + digit;\n+        }\n+        return num;\n     }\n \n-}\n\\ No newline at end of file\n+    public static class UnsolvablePuzzleException extends Exception {\n+        public UnsolvablePuzzleException(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    // Optional main method for local testing\n+    public static void main(String[] args) {\n+        if (args.length != 1) {\n+            System.err.println(\"Usage: java Alphametics '<PUZZLE>'\");\n+            System.exit(1);\n+        }\n+        try {\n+            Alphametics puzzle = new Alphametics(args[0]);\n+            Map<Character, Integer> solution = puzzle.solve();\n+            System.out.println(solution);\n+        } catch (Exception e) {\n+            System.err.println(e.getMessage());\n+            System.exit(1);\n+        }\n+    }\n+}\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}