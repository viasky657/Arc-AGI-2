{
    "instance_id": "cpp__circular-buffer",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/circular_buffer.h b/circular_buffer.h\nindex 07f91ed..981b1fe 100644\n--- a/circular_buffer.h\n+++ b/circular_buffer.h\n@@ -1,8 +1,64 @@\n #if !defined(CIRCULAR_BUFFER_H)\n #define CIRCULAR_BUFFER_H\n \n+#include <stdexcept>\n+#include <vector>\n+\n namespace circular_buffer {\n \n+class CircularBuffer {\n+public:\n+    // Construct a circular buffer with the given capacity\n+    explicit CircularBuffer(size_t capacity)\n+        : buffer_(capacity), capacity_(capacity), head_(0), tail_(0), count_(0) {}\n+\n+    // Push a new value into the buffer\n+    // Throws std::runtime_error if the buffer is full\n+    void push(int value) {\n+        if (isFull()) {\n+            throw std::runtime_error(\"Buffer is full\");\n+        }\n+        buffer_[tail_] = value;\n+        tail_ = (tail_ + 1) % capacity_;\n+        ++count_;\n+    }\n+\n+    // Forcefully push a new value into the buffer\n+    // If the buffer is full, this overwrites the oldest element\n+    void forcePush(int value) {\n+        if (isFull()) {\n+            // Overwrite the oldest element, which is at head_\n+            buffer_[head_] = value;\n+            head_ = (head_ + 1) % capacity_;\n+            tail_ = head_; // tail follows head in a full buffer\n+        } else {\n+            push(value);\n+        }\n+    }\n+\n+    // Remove and return the oldest element in the buffer\n+    // Throws std::runtime_error if the buffer is empty\n+    int pop() {\n+        if (isEmpty()) {\n+            throw std::runtime_error(\"Buffer is empty\");\n+        }\n+        int value = buffer_[head_];\n+        head_ = (head_ + 1) % capacity_;\n+        --count_;\n+        return value;\n+    }\n+\n+    bool isFull() const { return count_ == capacity_; }\n+    bool isEmpty() const { return count_ == 0; }\n+\n+private:\n+    std::vector<int> buffer_;\n+    size_t capacity_;\n+    size_t head_;  // points to the oldest element\n+    size_t tail_;  // points to the next write position when not full; for force push in full state, tail_ is set to head_\n+    size_t count_;\n+};\n+\n }  // namespace circular_buffer\n \n-#endif // CIRCULAR_BUFFER_H\n\\ No newline at end of file\n+#endif // CIRCULAR_BUFFER_H\ndiff --git a/test/circular_buffer_tests.cpp b/test/circular_buffer_tests.cpp\nnew file mode 100644\nindex 0000000..6a4c852\n--- /dev/null\n+++ b/test/circular_buffer_tests.cpp\n@@ -0,0 +1,64 @@\n+#include \"catch.hpp\"\n+#include \"circular_buffer.h\"\n+#include <stdexcept>\n+\n+using namespace circular_buffer;\n+\n+TEST_CASE(\"Normal push/pop operations\", \"[CircularBuffer]\") {\n+    // Create a CircularBuffer with capacity 7\n+    CircularBuffer cb(7);\n+\n+    // Simulate insertion: push 1, 2, 3\n+    cb.push(1);\n+    cb.push(2);\n+    cb.push(3);\n+\n+    // Remove two elements; they should be 1 and 2\n+    REQUIRE(cb.pop() == 1);\n+    REQUIRE(cb.pop() == 2);\n+    \n+    // Buffer now only contains '3'\n+    // Fill the buffer with additional elements to reach full capacity.\n+    cb.push(4);\n+    cb.push(5);\n+    cb.push(6);\n+    cb.push(7);\n+    cb.push(8);  // After these push operations, we have 1 (from before) + 5 = 6 elements\n+    cb.push(9);  // Now the buffer is full (7 elements total)\n+\n+    // Test that a normal push on a full buffer throws an error\n+    REQUIRE_THROWS_AS(cb.push(10), std::runtime_error);\n+\n+    // Use forcePush to overwrite the oldest element\n+    // Before forcePush, the buffer's order (from oldest to newest) is: 3,4,5,6,7,8,9\n+    // forcePush should overwrite the oldest (3) with 10, and adjust pointers\n+    cb.forcePush(10);\n+    \n+    // Now, the order should be: 4,5,6,7,8,9,10\n+    REQUIRE(cb.pop() == 4);\n+    REQUIRE(cb.pop() == 5);\n+    \n+    // Further test the buffer state.\n+    // Current buffer order: 6,7,8,9,10 with head pointing to 6.\n+    // Remove one element\n+    REQUIRE(cb.pop() == 6);\n+    \n+    // Not full now, so normal push works\n+    cb.push(11);\n+    \n+    // The order now should be: 7,8,9,10,11\n+    REQUIRE(cb.pop() == 7);\n+}\n+\n+TEST_CASE(\"Pop on empty buffer should raise exception\", \"[CircularBuffer]\") {\n+    CircularBuffer cb(3);\n+    REQUIRE_THROWS_AS(cb.pop(), std::runtime_error);\n+}\n+\n+TEST_CASE(\"Force push when buffer is not full acts as normal push\", \"[CircularBuffer]\") {\n+    CircularBuffer cb(3);\n+    cb.push(1);\n+    cb.forcePush(2); // Buffer is not full, so this should queue normally\n+    REQUIRE(cb.pop() == 1);\n+    REQUIRE(cb.pop() == 2);\n+}\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}