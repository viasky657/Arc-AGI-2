{
    "instance_id": "go__tree-building",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/tree_building.go b/tree_building.go\nindex 0b789a5..daaffdc 100644\n--- a/tree_building.go\n+++ b/tree_building.go\n@@ -1,17 +1,73 @@\n package tree\n \n+import \"errors\"\n+\n+// Record represents a single record with an ID and a Parent.\n+// The ID is always between 0 (inclusive) and the length of the record list (exclusive).\n+// The root record (ID 0) must have Parent equal to its own ID.\n+// All other records must have Parent less than their own ID.\n+\n type Record struct {\n \tID     int\n \tParent int\n \t// feel free to add fields as you see fit\n }\n \n+// Node represents a node in the tree with an ID and a list of its children.\n+// Additional fields can be added as necessary.\n+\n type Node struct {\n \tID       int\n \tChildren []*Node\n \t// feel free to add fields as you see fit\n }\n \n+// Build constructs a tree from an unsorted slice of Record.\n+// It returns the root node and an error if the records form an invalid tree.\n func Build(records []Record) (*Node, error) {\n-\tpanic(\"Please implement the Build function\")\n+\tif len(records) == 0 {\n+\t\treturn nil, nil\n+\t}\n+\n+\tn := len(records)\n+\t// Create a slice to hold records sorted by their ID. Since valid records have IDs\n+\t// in the interval [0,n), we can index them directly.\n+\tsortedRecords := make([]Record, n)\n+\tfilled := make([]bool, n)\n+\n+\tfor _, rec := range records {\n+\t\tif rec.ID < 0 || rec.ID >= n {\n+\t\t\treturn nil, errors.New(\"record id out of bounds\")\n+\t\t}\n+\t\tif filled[rec.ID] {\n+\t\t\treturn nil, errors.New(\"duplicate record\")\n+\t\t}\n+\t\tfilled[rec.ID] = true\n+\t\tsortedRecords[rec.ID] = rec\n+\t}\n+\n+\t// Validate records and create nodes.\n+\tnodes := make([]*Node, n)\n+\tfor i, rec := range sortedRecords {\n+\t\tif i == 0 {\n+\t\t\tif rec.ID != 0 || rec.Parent != 0 {\n+\t\t\t\treturn nil, errors.New(\"root record is invalid\")\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// For non-root records, parent must be less than the record's id\n+\t\t\tif rec.Parent >= rec.ID {\n+\t\t\t\treturn nil, errors.New(\"parent id must be less than record id\")\n+\t\t\t}\n+\t\t}\n+\t\tnodes[i] = &Node{ID: rec.ID}\n+\t}\n+\n+\t// Build tree by assigning children to their parents\n+\tfor i := 1; i < n; i++ { // skip root\n+\t\trec := sortedRecords[i]\n+\t\tparent := nodes[rec.Parent]\n+\t\tparent.Children = append(parent.Children, nodes[i])\n+\t}\n+\n+\treturn nodes[0], nil\n }\n",
    "proposed_model_patches": [],
    "eval_result": "resolved",
    "success": true
}