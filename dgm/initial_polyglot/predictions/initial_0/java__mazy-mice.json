{
    "instance_id": "java__mazy-mice",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/src/main/java/MazeGenerator.java b/src/main/java/MazeGenerator.java\nindex 48c0bda..15fb093 100644\n--- a/src/main/java/MazeGenerator.java\n+++ b/src/main/java/MazeGenerator.java\n@@ -1,10 +1,149 @@\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Random;\n+\n public class MazeGenerator {\n \n+    private static final int TOP = 0, RIGHT = 1, BOTTOM = 2, LEFT = 3;\n+\n+    private static class Cell {\n+        boolean[] walls = {true, true, true, true}; // top, right, bottom, left\n+        boolean visited = false;\n+    }\n+\n     public char[][] generatePerfectMaze(int rows, int columns) {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n+        return generatePerfectMaze(rows, columns, new Random().nextInt());\n     }\n \n     public char[][] generatePerfectMaze(int rows, int columns, int seed) {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n+        if (rows < 5 || rows > 100 || columns < 5 || columns > 100) {\n+            throw new IllegalArgumentException(\"Maze dimensions must be between 5 and 100 cells.\");\n+        }\n+        // Create grid of cells\n+        Cell[][] maze = new Cell[rows][columns];\n+        for (int r = 0; r < rows; r++) {\n+            for (int c = 0; c < columns; c++) {\n+                maze[r][c] = new Cell();\n+            }\n+        }\n+\n+        Random rand = new Random(seed);\n+        carvePassagesFrom(0, 0, maze, rows, columns, rand);\n+\n+        // Create entrance and exit\n+        // Entrance: remove left wall of top-left cell\n+        maze[0][0].walls[LEFT] = false;\n+        // Exit: remove right wall of bottom-right cell\n+        maze[rows - 1][columns - 1].walls[RIGHT] = false;\n+\n+        // Build the ASCII drawing using box-drawing characters\n+        int h = 2 * rows + 1;\n+        int w = 2 * columns + 1;\n+        char[][] grid = new char[h][w];\n+\n+        // Initialize grid with spaces\n+        for (int i = 0; i < h; i++) {\n+            for (int j = 0; j < w; j++) {\n+                grid[i][j] = ' ';\n+            }\n+        }\n+\n+        // Fill in horizontal walls from cells\n+        // For each cell at (r,c), its top wall is drawn at (2*r, 2*c+1) if exists and bottom at (2*r+2, 2*c+1)\n+        for (int r = 0; r < rows; r++) {\n+            for (int c = 0; c < columns; c++) {\n+                if (maze[r][c].walls[TOP]) {\n+                    grid[2 * r][2 * c + 1] = '\u2500';\n+                }\n+                if (maze[r][c].walls[BOTTOM]) {\n+                    grid[2 * r + 2][2 * c + 1] = '\u2500';\n+                }\n+                if (maze[r][c].walls[LEFT]) {\n+                    grid[2 * r + 1][2 * c] = '\u2502';\n+                }\n+                if (maze[r][c].walls[RIGHT]) {\n+                    grid[2 * r + 1][2 * c + 2] = '\u2502';\n+                }\n+            }\n+        }\n+\n+        // Fill in corners and border intersections\n+        for (int i = 0; i < h; i += 2) {\n+            for (int j = 0; j < w; j += 2) {\n+                // Determine which border this intersection is on\n+                boolean topEdge = (i == 0);\n+                boolean bottomEdge = (i == h - 1);\n+                boolean leftEdge = (j == 0);\n+                boolean rightEdge = (j == w - 1);\n+\n+                if (topEdge && leftEdge) {\n+                    grid[i][j] = '\u250c';\n+                } else if (topEdge && rightEdge) {\n+                    grid[i][j] = '\u2510';\n+                } else if (bottomEdge && leftEdge) {\n+                    grid[i][j] = '\u2514';\n+                } else if (bottomEdge && rightEdge) {\n+                    grid[i][j] = '\u2518';\n+                } else if (topEdge) {\n+                    grid[i][j] = '\u252c';\n+                } else if (bottomEdge) {\n+                    grid[i][j] = '\u2534';\n+                } else if (leftEdge) {\n+                    grid[i][j] = '\u251c';\n+                } else if (rightEdge) {\n+                    grid[i][j] = '\u2524';\n+                } else {\n+                    grid[i][j] = '\u253c';\n+                }\n+            }\n+        }\n+\n+        // Place entrance and exit arrows. Entrance on left, exit on right.\n+        // Entrance: at the left border of cell (0,0) i.e. (2*0+1, 0)\n+        grid[1][0] = '\u21e8';\n+        // Exit: at the right border of cell (rows-1, columns-1) i.e. (2*(rows-1)+1, 2*columns)\n+        grid[2 * rows - 1][w - 1] = '\u21e8';\n+\n+        return grid;\n+    }\n+\n+    private void carvePassagesFrom(int r, int c, Cell[][] maze, int rows, int columns, Random rand) {\n+        maze[r][c].visited = true;\n+\n+        List<int[]> directions = new ArrayList<>();\n+        directions.add(new int[]{-1, 0, TOP, BOTTOM});    // move up: remove top wall of current and bottom wall of neighbor\n+        directions.add(new int[]{0, 1, RIGHT, LEFT});     // move right\n+        directions.add(new int[]{1, 0, BOTTOM, TOP});       // move down\n+        directions.add(new int[]{0, -1, LEFT, RIGHT});      // move left\n+\n+        Collections.shuffle(directions, rand);\n+\n+        for (int[] dir : directions) {\n+            int nr = r + dir[0];\n+            int nc = c + dir[1];\n+            if (nr >= 0 && nr < rows && nc >= 0 && nc < columns && !maze[nr][nc].visited) {\n+                // Remove walls between current cell and neighbor\n+                maze[r][c].walls[dir[2]] = false;\n+                maze[nr][nc].walls[dir[3]] = false;\n+                carvePassagesFrom(nr, nc, maze, rows, columns, rand);\n+            }\n+        }\n+    }\n+\n+    // For debugging, a method to print the maze to console\n+    public void printMaze(char[][] grid) {\n+        for (char[] row : grid) {\n+            System.out.println(new String(row));\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        MazeGenerator mg = new MazeGenerator();\n+        int rows = 5;\n+        int cols = 5;\n+        int seed = 12345;\n+        char[][] maze = mg.generatePerfectMaze(rows, cols, seed);\n+        mg.printMaze(maze);\n     }\n }\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}