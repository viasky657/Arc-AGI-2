{
    "instance_id": "java__go-counting",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/src/main/java/GoCounting.java b/src/main/java/GoCounting.java\nindex 23907fd..6e3c2e5 100644\n--- a/src/main/java/GoCounting.java\n+++ b/src/main/java/GoCounting.java\n@@ -1,23 +1,237 @@\n import java.awt.Point;\n-import java.util.Map;\n-import java.util.Set;\n+import java.util.*;\n \n-class GoCounting {\n+public class GoCounting {\n \n-    GoCounting(String board) {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n+    // Define players for clarity\n+    public enum Player {\n+        BLACK, WHITE;\n     }\n \n-    Player getTerritoryOwner(int x, int y) {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n+    // Board representation: board[y][x]\n+    private final char[][] board;\n+    private final int width;\n+    private final int height;\n+\n+    // We assume that the board string can be provided in two formats:\n+    // 1. A plain board with each row representing a line of the board using characters:\n+    //    'B' for Black stone, 'W' for White stone, and ' ' (space) for empty intersections.\n+    // 2. A framed board where the first and last lines are borders starting with '+' and containing '-';\n+    //    and each interior line starts with '|' and ends with '|'. In that case, we remove the frame.\n+    \n+    public GoCounting(String boardString) {\n+        // Split the board string into lines\n+        String[] lines = boardString.split(\"\\r?\\n\");\n+        List<String> boardLines = new ArrayList<>();\n+        \n+        // Check if the board is framed by a border\n+        if (lines.length > 0 && lines[0].startsWith(\"+\")) {\n+            // Assuming the first and last lines are borders, and each interior line starts and ends with '|'\n+            for (int i = 1; i < lines.length - 1; i++) {\n+                String line = lines[i];\n+                // Remove the first and last character if they are '|'\n+                if (line.length() >= 2 && line.charAt(0) == '|' && line.charAt(line.length()-1) == '|') {\n+                    boardLines.add(line.substring(1, line.length()-1));\n+                } else {\n+                    boardLines.add(line);\n+                }\n+            }\n+        } else {\n+            // Plain board\n+            boardLines = Arrays.asList(lines);\n+        }\n+        \n+        height = boardLines.size();\n+        if (height == 0) {\n+            throw new IllegalArgumentException(\"Board cannot be empty\");\n+        }\n+        width = boardLines.get(0).length();\n+        board = new char[height][width];\n+        for (int y = 0; y < height; y++) {\n+            String line = boardLines.get(y);\n+            if (line.length() != width) {\n+                throw new IllegalArgumentException(\"All rows must have the same width\");\n+            }\n+            for (int x = 0; x < width; x++) {\n+                board[y][x] = line.charAt(x);\n+            }\n+        }\n+    }\n+\n+    // Flood fill to compute the connected region of empty intersections starting from (x,y).\n+    // Also collects the set of stone characters that border the region.\n+    private void floodFill(int startX, int startY, Set<Point> region, Set<Character> borderStones, boolean[][] visited) {\n+        // Boundary check\n+        if (startX < 0 || startX >= width || startY < 0 || startY >= height) return;\n+        if (visited[startY][startX]) return;\n+        visited[startY][startX] = true;\n+\n+        char cell = board[startY][startX];\n+        if (cell == ' ') {\n+            Point p = new Point(startX, startY);\n+            region.add(p);\n+            // Explore neighbors (up, down, left, right)\n+            floodFill(startX + 1, startY, region, borderStones, visited);\n+            floodFill(startX - 1, startY, region, borderStones, visited);\n+            floodFill(startX, startY + 1, region, borderStones, visited);\n+            floodFill(startX, startY - 1, region, borderStones, visited);\n+        } else {\n+            // It's a stone. Add to border stones.\n+            borderStones.add(cell);\n+        }\n+    }\n+\n+    // Given a starting coordinate, return the connected empty region and any bordering stone characters\n+    private Territory computeTerritoryRegion(int x, int y) {\n+        Set<Point> region = new HashSet<>();\n+        Set<Character> borderStones = new HashSet<>();\n+        boolean[][] visited = new boolean[height][width];\n+        floodFill(x, y, region, borderStones, visited);\n+        return new Territory(region, borderStones);\n+    }\n+\n+    // A simple helper class to store territory region and its bordering stones\n+    private static class Territory {\n+        Set<Point> region;\n+        Set<Character> borderStones;\n+        Territory(Set<Point> region, Set<Character> borderStones) {\n+            this.region = region;\n+            this.borderStones = borderStones;\n+        }\n+    }\n+\n+    // Helper to map stone character to Player. We assume 'B' for Black and 'W' for White.\n+    private Player playerForStone(char stone) {\n+        if (stone == 'B') return Player.BLACK;\n+        if (stone == 'W') return Player.WHITE;\n+        // For unrecognized stone, throw an error.\n+        throw new IllegalArgumentException(\"Unknown stone character: \" + stone);\n+    }\n+\n+    // Determines territory owner based on bordering stones.\n+    // If territory is completely surrounded by stones of one player, returns that player;\n+    // Else returns null.\n+    private Player determineOwner(Set<Character> borderStones) {\n+        // Remove any spaces if accidentally included (should not happen)\n+        Set<Character> stones = new HashSet<>();\n+        for (char c : borderStones) {\n+            if (c != ' ') {\n+                stones.add(c);\n+            }\n+        }\n+        if (stones.isEmpty()) {\n+            return null; // no bordering stones\n+        }\n+        // Map first stone to a player\n+        Iterator<Character> iter = stones.iterator();\n+        Player owner = playerForStone(iter.next());\n+        while (iter.hasNext()) {\n+            Player p = playerForStone(iter.next());\n+            if (p != owner) {\n+                return null; // Mixed bordering stones\n+            }\n+        }\n+        return owner;\n+    }\n+\n+    // Returns the territory (set of empty intersections) that includes the specified coordinate (x,y).\n+    // If the coordinate is not an empty intersection, returns an empty set.\n+    public Set<Point> getTerritory(int x, int y) {\n+        if (!isValidCoordinate(x, y)) {\n+            throw new IllegalArgumentException(\"Coordinate out of board\");\n+        }\n+        if (board[y][x] != ' ') {\n+            return Collections.emptySet();\n+        }\n+        Territory t = computeTerritoryRegion(x, y);\n+        return t.region;\n     }\n \n-    Set<Point> getTerritory(int x, int y) {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n+    // Returns the owner of the territory that includes the specified coordinate, or null if neutral or invalid.\n+    public Player getTerritoryOwner(int x, int y) {\n+        if (!isValidCoordinate(x, y)) {\n+            throw new IllegalArgumentException(\"Coordinate out of board\");\n+        }\n+        if (board[y][x] != ' ') {\n+            return null;\n+        }\n+        Territory t = computeTerritoryRegion(x, y);\n+        return determineOwner(t.borderStones);\n+    }\n+\n+    // Computes all territories on the board.\n+    // Returns a map from Player to set of Points that belong to that player's territory.\n+    public Map<Player, Set<Point>> getTerritories() {\n+        Map<Player, Set<Point>> territories = new EnumMap<>(Player.class);\n+        // use a visited matrix to avoid counting the same territory twice\n+        boolean[][] visited = new boolean[height][width];\n+\n+        for (int y = 0; y < height; y++) {\n+            for (int x = 0; x < width; x++) {\n+                if (board[y][x] == ' ' && !visited[y][x]) {\n+                    Set<Point> region = new HashSet<>();\n+                    Set<Character> borderStones = new HashSet<>();\n+                    floodFillWithVisited(x, y, region, borderStones, visited);\n+                    Player owner = determineOwner(borderStones);\n+                    if (owner != null) {\n+                        territories.computeIfAbsent(owner, k -> new HashSet<>()).addAll(region);\n+                    }\n+                }\n+            }\n+        }\n+        return territories;\n     }\n \n-    Map<Player, Set<Point>> getTerritories() {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n+    // A modified flood fill that marks visited in provided matrix\n+    private void floodFillWithVisited(int startX, int startY, Set<Point> region, Set<Character> borderStones, boolean[][] visited) {\n+        // boundary check\n+        if (startX < 0 || startX >= width || startY < 0 || startY >= height) return;\n+        if (visited[startY][startX]) return;\n+        visited[startY][startX] = true;\n+        char cell = board[startY][startX];\n+        if (cell == ' ') {\n+            region.add(new Point(startX, startY));\n+            floodFillWithVisited(startX + 1, startY, region, borderStones, visited);\n+            floodFillWithVisited(startX - 1, startY, region, borderStones, visited);\n+            floodFillWithVisited(startX, startY + 1, region, borderStones, visited);\n+            floodFillWithVisited(startX, startY - 1, region, borderStones, visited);\n+        } else {\n+            borderStones.add(cell);\n+        }\n     }\n \n-}\n\\ No newline at end of file\n+    private boolean isValidCoordinate(int x, int y) {\n+        return x >= 0 && x < width && y >= 0 && y < height;\n+    }\n+\n+    // (Optional) for debugging: print the board\n+    public void printBoard() {\n+        for (int y = 0; y < height; y++) {\n+            System.out.println(new String(board[y]));\n+        }\n+    }\n+\n+    // You can add a main method for simple testing\n+    public static void main(String[] args) {\n+        String board =\n+                \"+++++++\\n\" +\n+                \"|B   W|\\n\" +\n+                \"|  B  |\\n\" +\n+                \"| W   |\\n\" +\n+                \"+++++++\";\n+        GoCounting gc = new GoCounting(board);\n+        gc.printBoard();\n+        \n+        // Check a coordinate that is empty\n+        int x = 2, y = 1;\n+        Set<Point> territory = gc.getTerritory(x, y);\n+        Player owner = gc.getTerritoryOwner(x, y);\n+        System.out.println(\"Territory at (\" + x + \",\" + y + \") has \" + territory.size() + \" points and is owned by \" + owner);\n+        \n+        // Print all territories\n+        Map<Player, Set<Point>> all = gc.getTerritories();\n+        for (Map.Entry<Player, Set<Point>> entry : all.entrySet()) {\n+            System.out.println(entry.getKey() + \" territory: \" + entry.getValue().size() + \" points\");\n+        }\n+    }\n+}\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}