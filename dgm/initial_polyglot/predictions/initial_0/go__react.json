{
    "instance_id": "go__react",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/react.go b/react.go\nindex fabc3c0..cd52bb5 100644\n--- a/react.go\n+++ b/react.go\n@@ -1,36 +1,233 @@\n package react\n \n-// Define reactor, cell and canceler types here.\n-// These types will implement the Reactor, Cell and Canceler interfaces, respectively.\n+// Reactor, Cell and Canceler interfaces\n+//\n+// Reactor interface: allows creating input and computed cells.\n+// Cell interface: provides methods to get cell value, set value (for input cells) and add callbacks.\n+// Canceler interface: returned when adding a callback, and can be used to cancel a callback registration.\n \n+// We assume the following interfaces, which our types below implement:\n+\n+// Reactor is the interface for the reactive system\n+// type Reactor interface {\n+//     CreateInput(initial int) InputCell\n+//     CreateCompute1(dep Cell, compute func(int) int) ComputeCell\n+//     CreateCompute2(dep1, dep2 Cell, compute func(int, int) int) ComputeCell\n+// }\n+\n+// Cell is the interface for a cell in the reactive system\n+// type Cell interface {\n+//     Value() int\n+//     SetValue(value int)\n+//     AddCallback(callback func(int)) Canceler\n+// }\n+\n+// InputCell is a settable cell (an input cell) and ComputeCell is a computed cell; both implement Cell\n+//\n+// Canceler is the interface with a Cancel method to remove a registered callback\n+// type Canceler interface {\n+//     Cancel()\n+// }\n+\n+// The implementation below defines reactor, cell and canceler types that implement these interfaces.\n+\n+// New returns a new reactive system (Reactor)\n+func New() Reactor {\n+\treturn &reactor{}\n+}\n+\n+// Internal interfaces definitions for clarity\n+// Reactor, Cell, Canceler interfaces are implemented by reactor, cell and canceler respectively.\n+\n+// reactor struct: our reactive system implementation. It doesn't need to track all cells globally because dependency links are maintained among cells.\n+\n+type reactor struct{}\n+\n+// cellKind distinguishes between input and computed cells\n+\n+type cellKind int\n+\n+const (\n+\tkindInput cellKind = iota\n+\tkindCompute1\n+\tkindCompute2\n+)\n+\n+// cell struct represents both input and computed cells\n+// For computed cells, it stores the compute functions and dependencies; input cells only have a value.\n+// Each cell maintains a list of dependents (cells that directly depend on it) for propagation.\n+// For computed cells, lastNotified stores the value at the last time callbacks were fired.\n+// Each cell also holds a map of callbacks, keyed by callback id.\n+\n+type cell struct {\n+\treactor *reactor\n+\tkind    cellKind\n+\tvalue   int\n+\t// lastNotified is used for computed cells to track the last stable value where callbacks were called\n+\tlastNotified int\n+\t\n+\t// compute functions for computed cells\n+\tcompute1 func(int) int\n+\tcompute2 func(int, int) int\n+\t\n+\t// dependencies: for compute1, only dep1 is used; for compute2, both dep1 and dep2 are used\n+\tdep1 *cell\n+\tdep2 *cell\n+\t\n+\t// List of cells that depend on this cell\n+\tdependents []*cell\n+\t\n+\t// Callbacks registered for computed cells\n+\tcallbacks      map[int]func(int)\n+\tnextCallbackID int\n+}\n+\n+// canceller struct holds the information to cancel a registered callback\n+\n+type canceler struct {\n+\tcell     *cell\n+\tid       int\n+\tcanceled bool\n+}\n+\n+// Cancel removes the callback from its cell if not already canceled\n func (c *canceler) Cancel() {\n-\tpanic(\"Please implement the Cancel function\")\n+\tif c.canceled {\n+\t\treturn\n+\t}\n+\tif c.cell.callbacks != nil {\n+\t\tdelete(c.cell.callbacks, c.id)\n+\t}\n+\tc.canceled = true\n }\n \n+// Value returns the current value stored in the cell\n func (c *cell) Value() int {\n-\tpanic(\"Please implement the Value function\")\n+\treturn c.value\n }\n \n+// SetValue sets the value of an input cell and triggers propagation of changes\n+// Only input cells (kindInput) can be set\n func (c *cell) SetValue(value int) {\n-\tpanic(\"Please implement the SetValue function\")\n+\tif c.kind != kindInput {\n+\t\t// For computed cells, SetValue does nothing\n+\t\treturn\n+\t}\n+\tif c.value == value {\n+\t\treturn\n+\t}\n+\tc.value = value\n+\t// Propagate changes starting from this input cell\n+\tc.reactor.propagateFrom(c)\n }\n \n+// AddCallback registers a callback with the cell and returns a Canceler\n+// The callback is only used for computed cells\n func (c *cell) AddCallback(callback func(int)) Canceler {\n-\tpanic(\"Please implement the AddCallback function\")\n-}\n-\n-func New() Reactor {\n-\tpanic(\"Please implement the New function\")\n+\tif c.callbacks == nil {\n+\t\tc.callbacks = make(map[int]func(int))\n+\t}\n+\tc.nextCallbackID++\n+\tid := c.nextCallbackID\n+\tc.callbacks[id] = callback\n+\treturn &canceler{\n+\t\tcell: c,\n+\t\tid:   id,\n+\t}\n }\n \n+// CreateInput creates an input cell with the given initial value\n func (r *reactor) CreateInput(initial int) InputCell {\n-\tpanic(\"Please implement the CreateInput function\")\n+\tc := &cell{\n+\t\treactor:  r,\n+\t\tkind:      kindInput,\n+\t\tvalue:     initial,\n+\t\tcallbacks: make(map[int]func(int)),\n+\t}\n+\treturn c\n }\n \n+// CreateCompute1 creates a computed cell that depends on a single cell.\n+// The computed cell's value is determined by applying the compute function to the dependency's value.\n+// It also registers the computed cell as a dependent of the dependency.\n func (r *reactor) CreateCompute1(dep Cell, compute func(int) int) ComputeCell {\n-\tpanic(\"Please implement the CreateCompute1 function\")\n+\tdepCell := dep.(*cell)\n+\tc := &cell{\n+\t\treactor:  r,\n+\t\tkind:      kindCompute1,\n+\t\tdep1:      depCell,\n+\t\tcompute1:  compute,\n+\t\tcallbacks: make(map[int]func(int)),\n+\t}\n+\t// Initialize the cell's value from its dependency\n+\tc.value = compute(depCell.Value())\n+\tc.lastNotified = c.value\n+\t// Register c as a dependent in the dependency cell\n+\tdepCell.dependents = append(depCell.dependents, c)\n+\treturn c\n }\n \n+// CreateCompute2 creates a computed cell that depends on two cells.\n+// The computed cell's value is determined by applying the compute function to the two dependencies' values.\n+// It registers the computed cell as a dependent of both dependencies.\n func (r *reactor) CreateCompute2(dep1, dep2 Cell, compute func(int, int) int) ComputeCell {\n-\tpanic(\"Please implement the CreateCompute2 function\")\n+\tc1 := dep1.(*cell)\n+\tc2 := dep2.(*cell)\n+\tc := &cell{\n+\t\treactor:  r,\n+\t\tkind:      kindCompute2,\n+\t\tdep1:      c1,\n+\t\tdep2:      c2,\n+\t\tcompute2:  compute,\n+\t\tcallbacks: make(map[int]func(int)),\n+\t}\n+\tc.value = compute(c1.Value(), c2.Value())\n+\tc.lastNotified = c.value\n+\t// Register c as dependent of both dependency cells\n+\tc1.dependents = append(c1.dependents, c)\n+\tc2.dependents = append(c2.dependents, c)\n+\treturn c\n+}\n+\n+// propagateFrom performs a breadth-first propagation of changes starting from a changed cell.\n+// It updates computed cells whose dependencies have changed, and if a computed cell's value changes,\n+// it enqueues its dependents for re-evaluation. After stabilization, callbacks are fired for computed cells\n+// whose final value differs from their last notified value.\n+func (r *reactor) propagateFrom(changed *cell) {\n+\tqueue := []*cell{}\n+\tqueue = append(queue, changed.dependents...)\n+\n+\t// updated keeps track of computed cells that have been updated during propagation\n+\tupdated := make(map[*cell]bool)\n+\n+\t// Process the queue until no more cells need re-evaluation\n+\tfor len(queue) > 0 {\n+\t\tcurrent := queue[0]\n+\t\tqueue = queue[1:]\n+\t\tvar newVal int\n+\t\tswitch current.kind {\n+\t\tcase kindCompute1:\n+\t\t\tnewVal = current.compute1(current.dep1.Value())\n+\t\tcase kindCompute2:\n+\t\t\tnewVal = current.compute2(current.dep1.Value(), current.dep2.Value())\n+\t\tdefault:\n+\t\t\tcontinue\n+\t\t}\n+\t\tif newVal != current.value {\n+\t\t\tcurrent.value = newVal\n+\t\t\tupdated[current] = true\n+\t\t\t// Enqueue current cell's dependents because its change may affect them\n+\t\t\tqueue = append(queue, current.dependents...)\n+\t\t}\n+\t}\n+\n+\t// After propagation, fire callbacks for each computed cell that changed from its last stable state\n+\tfor cellPtr := range updated {\n+\t\tif cellPtr.value != cellPtr.lastNotified {\n+\t\t\tfor _, cb := range cellPtr.callbacks {\n+\t\t\t\tcb(cellPtr.value)\n+\t\t\t}\n+\t\t\tcellPtr.lastNotified = cellPtr.value\n+\t\t}\n+\t}\n }\n",
    "proposed_model_patches": [],
    "eval_result": "resolved",
    "success": true
}