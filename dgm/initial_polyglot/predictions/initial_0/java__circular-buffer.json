{
    "instance_id": "java__circular-buffer",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/src/main/java/CircularBuffer.java b/src/main/java/CircularBuffer.java\nindex 0abe277..918f0bf 100644\n--- a/src/main/java/CircularBuffer.java\n+++ b/src/main/java/CircularBuffer.java\n@@ -1,23 +1,108 @@\n-class CircularBuffer<T> {\n+public class CircularBuffer<T> {\n+    private T[] buffer;\n+    private int head;       // points to the oldest element\n+    private int tail;       // points to next write position\n+    private int capacity;   // fixed buffer capacity\n+    private int count;      // current number of elements\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public CircularBuffer(final int size) {\n+        if (size <= 0) {\n+            throw new IllegalArgumentException(\"Size must be greater than zero\");\n+        }\n+        this.capacity = size;\n+        this.buffer = (T[]) new Object[size];\n+        this.head = 0;\n+        this.tail = 0;\n+        this.count = 0;\n+    }\n \n-    CircularBuffer(final int size) {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n+    /**\n+     * Reads (and removes) the oldest element from the ring buffer.\n+     * @return the oldest element\n+     * @throws BufferIOException if the buffer is empty\n+     */\n+    public T read() throws BufferIOException {\n+        if (count == 0) {\n+            throw new BufferIOException(\"Ring buffer is empty\");\n+        }\n+        T element = buffer[head];\n+        buffer[head] = null; // Help garbage collection\n+        head = (head + 1) % capacity;\n+        count--;\n+        return element;\n     }\n \n-    T read() throws BufferIOException {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n+    /**\n+     * Writes data into the ring buffer if space is available.\n+     * @param data the data to write\n+     * @throws BufferIOException if the buffer is full\n+     */\n+    public void write(T data) throws BufferIOException {\n+        if (count == capacity) {\n+            throw new BufferIOException(\"Ring buffer is full\");\n+        }\n+        buffer[tail] = data;\n+        tail = (tail + 1) % capacity;\n+        count++;\n     }\n \n-    void write(T data) throws BufferIOException {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n+    /**\n+     * Writes data into the ring buffer, overwriting the oldest data if the buffer is full.\n+     * If the buffer is not full, it behaves like a normal write().\n+     * @param data the data to write\n+     */\n+    public void overwrite(T data) {\n+        if (count == capacity) {\n+            // Overwrite the element at tail (which is the next write position), then advance both head and tail\n+            buffer[tail] = data;\n+            tail = (tail + 1) % capacity;\n+            head = tail; // Since buffer was full, the oldest element has been overwritten\n+        } else {\n+            try {\n+                write(data);\n+            } catch (BufferIOException e) {\n+                // This catch should never occur because we already checked count < capacity\n+                throw new RuntimeException(e);\n+            }\n+        }\n     }\n \n-    void overwrite(T data) {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n+    /**\n+     * Clears the buffer, removing all elements.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void clear() {\n+        // Optionally, clear out references\n+        for (int i = 0; i < capacity; i++) {\n+            buffer[i] = null;\n+        }\n+        head = 0;\n+        tail = 0;\n+        count = 0;\n     }\n \n-    void clear() {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n+    /**\n+     * Exception thrown when a read or write operation cannot be completed on the ring buffer.\n+     */\n+    public static class BufferIOException extends Exception {\n+        public BufferIOException(String message) {\n+            super(message);\n+        }\n     }\n \n-}\n\\ No newline at end of file\n+    // For debugging, a method to return a string representation of the internal state.\n+    public String debugString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"Buffer: [\");\n+        for (int i = 0; i < capacity; i++) {\n+            sb.append(buffer[i]);\n+            if (i < capacity - 1) {\n+                sb.append(\", \");\n+            }\n+        }\n+        sb.append(\"]\\n\");\n+        sb.append(\"head index: \" + head + \", tail index: \" + tail + \", count: \" + count);\n+        return sb.toString();\n+    }\n+}\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}