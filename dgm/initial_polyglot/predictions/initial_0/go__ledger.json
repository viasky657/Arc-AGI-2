{
    "instance_id": "go__ledger",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/ledger.go b/ledger.go\nindex 42b96d8..b05be0a 100644\n--- a/ledger.go\n+++ b/ledger.go\n@@ -2,224 +2,241 @@ package ledger\n \n import (\n \t\"errors\"\n+\t\"sort\"\n \t\"strconv\"\n \t\"strings\"\n )\n \n+// Change Log:\n+// - Introduced helper functions: sortEntries, formatHeader, formatDate, formatDescription, formatAmount, padRight, and padLeft.\n+// - Replaced the custom bubble-sort implementation with sort.SliceStable for clarity and correctness.\n+// - Removed duplicated formatting code by splitting date and currency formatting into separate functions.\n+// - Simplified the concurrent formatting of each ledger entry using the helper functions.\n+// - Maintained behavior for empty entry slice and error handling as in the original code.\n+\n+// Entry represents a ledger entry with a date, description, and change (in cents).\n type Entry struct {\n \tDate        string // \"Y-m-d\"\n \tDescription string\n \tChange      int // in cents\n }\n \n+// FormatLedger formats the ledger based on the provided currency (\"USD\" or \"EUR\") and locale (\"en-US\" or \"nl-NL\").\n func FormatLedger(currency string, locale string, entries []Entry) (string, error) {\n-\tvar entriesCopy []Entry\n-\tfor _, e := range entries {\n-\t\tentriesCopy = append(entriesCopy, e)\n-\t}\n+\t// If no entries provided, validate with a default entry\n \tif len(entries) == 0 {\n \t\tif _, err := FormatLedger(currency, \"en-US\", []Entry{{Date: \"2014-01-01\", Description: \"\", Change: 0}}); err != nil {\n \t\t\treturn \"\", err\n \t\t}\n \t}\n-\tm1 := map[bool]int{true: 0, false: 1}\n-\tm2 := map[bool]int{true: -1, false: 1}\n-\tes := entriesCopy\n-\tfor len(es) > 1 {\n-\t\tfirst, rest := es[0], es[1:]\n-\t\tsuccess := false\n-\t\tfor !success {\n-\t\t\tsuccess = true\n-\t\t\tfor i, e := range rest {\n-\t\t\t\tif (m1[e.Date == first.Date]*m2[e.Date < first.Date]*4 +\n-\t\t\t\t\tm1[e.Description == first.Description]*m2[e.Description < first.Description]*2 +\n-\t\t\t\t\tm1[e.Change == first.Change]*m2[e.Change < first.Change]*1) < 0 {\n-\t\t\t\t\tes[0], es[i+1] = es[i+1], es[0]\n-\t\t\t\t\tsuccess = false\n-\t\t\t\t}\n+\n+\t// Make a copy and sort the entries\n+\tsortedEntries := make([]Entry, len(entries))\n+\tcopy(sortedEntries, entries)\n+\tsortEntries(sortedEntries)\n+\n+\t// Get header\n+\theader, err := formatHeader(locale)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\n+\tresult := header\n+\n+\t// Channel to collect formatted rows concurrently\n+\ttype rowResult struct {\n+\t\ti   int\n+\t\ts   string\n+\t\terr error\n+\t}\n+\tch := make(chan rowResult)\n+\n+\tfor i, entry := range sortedEntries {\n+\t\tgo func(i int, entry Entry) {\n+\t\t\t// Format date\n+\t\t\td, err := formatDate(entry.Date, locale)\n+\t\t\tif err != nil {\n+\t\t\t\tch <- rowResult{i, \"\", err}\n+\t\t\t\treturn\n \t\t\t}\n+\n+\t\t\t// Format description\n+\t\t\tdesc := formatDescription(entry.Description)\n+\n+\t\t\t// Format amount\n+\t\t\tamt, err := formatAmount(entry.Change, currency, locale)\n+\t\t\tif err != nil {\n+\t\t\t\tch <- rowResult{i, \"\", err}\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tline := padRight(d, 10) + \" | \" + desc + \" | \" + padLeft(amt, 13) + \"\\n\"\n+\t\t\tch <- rowResult{i, line, nil}\n+\t\t}(i, entry)\n+\t}\n+\n+\tlines := make([]string, len(sortedEntries))\n+\tfor i := 0; i < len(sortedEntries); i++ {\n+\t\tres := <-ch\n+\t\tif res.err != nil {\n+\t\t\treturn \"\", res.err\n \t\t}\n-\t\tes = es[1:]\n+\t\tlines[res.i] = res.s\n+\t}\n+\n+\tfor _, line := range lines {\n+\t\tresult += line\n \t}\n \n-\tvar s string\n+\treturn result, nil\n+}\n+\n+// sortEntries sorts the ledger entries by date, then description, then change.\n+func sortEntries(entries []Entry) {\n+\tsort.SliceStable(entries, func(i, j int) bool {\n+\t\tif entries[i].Date != entries[j].Date {\n+\t\t\treturn entries[i].Date < entries[j].Date\n+\t\t}\n+\t\tif entries[i].Description != entries[j].Description {\n+\t\t\treturn entries[i].Description < entries[j].Description\n+\t\t}\n+\t\treturn entries[i].Change < entries[j].Change\n+\t})\n+}\n+\n+// formatHeader returns the ledger header based on the locale.\n+func formatHeader(locale string) (string, error) {\n \tif locale == \"nl-NL\" {\n-\t\ts = \"Datum\" +\n-\t\t\tstrings.Repeat(\" \", 10-len(\"Datum\")) +\n-\t\t\t\" | \" +\n-\t\t\t\"Omschrijving\" +\n-\t\t\tstrings.Repeat(\" \", 25-len(\"Omschrijving\")) +\n-\t\t\t\" | \" + \"Verandering\" + \"\\n\"\n+\t\treturn \"Datum      | Omschrijving             | Verandering\\n\", nil\n \t} else if locale == \"en-US\" {\n-\t\ts = \"Date\" +\n-\t\t\tstrings.Repeat(\" \", 10-len(\"Date\")) +\n-\t\t\t\" | \" +\n-\t\t\t\"Description\" +\n-\t\t\tstrings.Repeat(\" \", 25-len(\"Description\")) +\n-\t\t\t\" | \" + \"Change\" + \"\\n\"\n-\t} else {\n-\t\treturn \"\", errors.New(\"\")\n+\t\treturn \"Date       | Description              | Change\\n\", nil\n \t}\n-\t// Parallelism, always a great idea\n-\tco := make(chan struct {\n-\t\ti int\n-\t\ts string\n-\t\te error\n-\t})\n-\tfor i, et := range entriesCopy {\n-\t\tgo func(i int, entry Entry) {\n-\t\t\tif len(entry.Date) != 10 {\n-\t\t\t\tco <- struct {\n-\t\t\t\t\ti int\n-\t\t\t\t\ts string\n-\t\t\t\t\te error\n-\t\t\t\t}{e: errors.New(\"\")}\n-\t\t\t}\n-\t\t\td1, d2, d3, d4, d5 := entry.Date[0:4], entry.Date[4], entry.Date[5:7], entry.Date[7], entry.Date[8:10]\n-\t\t\tif d2 != '-' {\n-\t\t\t\tco <- struct {\n-\t\t\t\t\ti int\n-\t\t\t\t\ts string\n-\t\t\t\t\te error\n-\t\t\t\t}{e: errors.New(\"\")}\n-\t\t\t}\n-\t\t\tif d4 != '-' {\n-\t\t\t\tco <- struct {\n-\t\t\t\t\ti int\n-\t\t\t\t\ts string\n-\t\t\t\t\te error\n-\t\t\t\t}{e: errors.New(\"\")}\n-\t\t\t}\n-\t\t\tde := entry.Description\n-\t\t\tif len(de) > 25 {\n-\t\t\t\tde = de[:22] + \"...\"\n-\t\t\t} else {\n-\t\t\t\tde = de + strings.Repeat(\" \", 25-len(de))\n-\t\t\t}\n-\t\t\tvar d string\n-\t\t\tif locale == \"nl-NL\" {\n-\t\t\t\td = d5 + \"-\" + d3 + \"-\" + d1\n-\t\t\t} else if locale == \"en-US\" {\n-\t\t\t\td = d3 + \"/\" + d5 + \"/\" + d1\n-\t\t\t}\n-\t\t\tnegative := false\n-\t\t\tcents := entry.Change\n-\t\t\tif cents < 0 {\n-\t\t\t\tcents = cents * -1\n-\t\t\t\tnegative = true\n-\t\t\t}\n-\t\t\tvar a string\n-\t\t\tif locale == \"nl-NL\" {\n-\t\t\t\tif currency == \"EUR\" {\n-\t\t\t\t\ta += \"\u20ac\"\n-\t\t\t\t} else if currency == \"USD\" {\n-\t\t\t\t\ta += \"$\"\n-\t\t\t\t} else {\n-\t\t\t\t\tco <- struct {\n-\t\t\t\t\t\ti int\n-\t\t\t\t\t\ts string\n-\t\t\t\t\t\te error\n-\t\t\t\t\t}{e: errors.New(\"\")}\n-\t\t\t\t}\n-\t\t\t\ta += \" \"\n-\t\t\t\tcentsStr := strconv.Itoa(cents)\n-\t\t\t\tswitch len(centsStr) {\n-\t\t\t\tcase 1:\n-\t\t\t\t\tcentsStr = \"00\" + centsStr\n-\t\t\t\tcase 2:\n-\t\t\t\t\tcentsStr = \"0\" + centsStr\n-\t\t\t\t}\n-\t\t\t\trest := centsStr[:len(centsStr)-2]\n-\t\t\t\tvar parts []string\n-\t\t\t\tfor len(rest) > 3 {\n-\t\t\t\t\tparts = append(parts, rest[len(rest)-3:])\n-\t\t\t\t\trest = rest[:len(rest)-3]\n-\t\t\t\t}\n-\t\t\t\tif len(rest) > 0 {\n-\t\t\t\t\tparts = append(parts, rest)\n-\t\t\t\t}\n-\t\t\t\tfor i := len(parts) - 1; i >= 0; i-- {\n-\t\t\t\t\ta += parts[i] + \".\"\n-\t\t\t\t}\n-\t\t\t\ta = a[:len(a)-1]\n-\t\t\t\ta += \",\"\n-\t\t\t\ta += centsStr[len(centsStr)-2:]\n-\t\t\t\tif negative {\n-\t\t\t\t\ta += \"-\"\n-\t\t\t\t} else {\n-\t\t\t\t\ta += \" \"\n-\t\t\t\t}\n-\t\t\t} else if locale == \"en-US\" {\n-\t\t\t\tif negative {\n-\t\t\t\t\ta += \"(\"\n-\t\t\t\t}\n-\t\t\t\tif currency == \"EUR\" {\n-\t\t\t\t\ta += \"\u20ac\"\n-\t\t\t\t} else if currency == \"USD\" {\n-\t\t\t\t\ta += \"$\"\n-\t\t\t\t} else {\n-\t\t\t\t\tco <- struct {\n-\t\t\t\t\t\ti int\n-\t\t\t\t\t\ts string\n-\t\t\t\t\t\te error\n-\t\t\t\t\t}{e: errors.New(\"\")}\n-\t\t\t\t}\n-\t\t\t\tcentsStr := strconv.Itoa(cents)\n-\t\t\t\tswitch len(centsStr) {\n-\t\t\t\tcase 1:\n-\t\t\t\t\tcentsStr = \"00\" + centsStr\n-\t\t\t\tcase 2:\n-\t\t\t\t\tcentsStr = \"0\" + centsStr\n-\t\t\t\t}\n-\t\t\t\trest := centsStr[:len(centsStr)-2]\n-\t\t\t\tvar parts []string\n-\t\t\t\tfor len(rest) > 3 {\n-\t\t\t\t\tparts = append(parts, rest[len(rest)-3:])\n-\t\t\t\t\trest = rest[:len(rest)-3]\n-\t\t\t\t}\n-\t\t\t\tif len(rest) > 0 {\n-\t\t\t\t\tparts = append(parts, rest)\n-\t\t\t\t}\n-\t\t\t\tfor i := len(parts) - 1; i >= 0; i-- {\n-\t\t\t\t\ta += parts[i] + \",\"\n-\t\t\t\t}\n-\t\t\t\ta = a[:len(a)-1]\n-\t\t\t\ta += \".\"\n-\t\t\t\ta += centsStr[len(centsStr)-2:]\n-\t\t\t\tif negative {\n-\t\t\t\t\ta += \")\"\n-\t\t\t\t} else {\n-\t\t\t\t\ta += \" \"\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tco <- struct {\n-\t\t\t\t\ti int\n-\t\t\t\t\ts string\n-\t\t\t\t\te error\n-\t\t\t\t}{e: errors.New(\"\")}\n+\treturn \"\", errors.New(\"invalid locale\")\n+}\n+\n+// formatDate formats the date according to locale. Expects date in \"YYYY-MM-DD\" format.\n+func formatDate(date string, locale string) (string, error) {\n+\tif len(date) != 10 || date[4] != '-' || date[7] != '-' {\n+\t\treturn \"\", errors.New(\"invalid date format\")\n+\t}\n+\tyear := date[0:4]\n+\tmonth := date[5:7]\n+\tday := date[8:10]\n+\n+\tif locale == \"nl-NL\" {\n+\t\treturn day + \"-\" + month + \"-\" + year, nil\n+\t} else if locale == \"en-US\" {\n+\t\treturn month + \"/\" + day + \"/\" + year, nil\n+\t}\n+\treturn \"\", errors.New(\"invalid locale\")\n+}\n+\n+// formatDescription formats the description to a fixed length of 25 characters, truncating if needed.\n+func formatDescription(desc string) string {\n+\tif len(desc) > 25 {\n+\t\treturn desc[:22] + \"...\"\n+\t}\n+\treturn desc + strings.Repeat(\" \", 25-len(desc))\n+}\n+\n+// formatAmount formats the monetary amount according to currency and locale.\n+func formatAmount(change int, currency string, locale string) (string, error) {\n+\tnegative := change < 0\n+\tcents := change\n+\tif negative {\n+\t\tcents = -cents\n+\t}\n+\tcentsStr := strconv.Itoa(cents)\n+\tswitch len(centsStr) {\n+\tcase 1:\n+\t\tcentsStr = \"00\" + centsStr\n+\tcase 2:\n+\t\tcentsStr = \"0\" + centsStr\n+\t}\n+\tintPart := centsStr[:len(centsStr)-2]\n+\tvar result string\n+\n+\tif locale == \"nl-NL\" {\n+\t\tif currency == \"EUR\" {\n+\t\t\tresult += \"\u20ac \"\n+\t\t} else if currency == \"USD\" {\n+\t\t\tresult += \"$ \"\n+\t\t} else {\n+\t\t\treturn \"\", errors.New(\"invalid currency\")\n+\t\t}\n+\n+\t\tvar parts []string\n+\t\tfor len(intPart) > 3 {\n+\t\t\tparts = append(parts, intPart[len(intPart)-3:])\n+\t\t\tintPart = intPart[:len(intPart)-3]\n+\t\t}\n+\t\tif len(intPart) > 0 {\n+\t\t\tparts = append(parts, intPart)\n+\t\t}\n+\t\t// Reverse parts\n+\t\tfor i := len(parts) - 1; i >= 0; i-- {\n+\t\t\tresult += parts[i]\n+\t\t\tif i > 0 {\n+\t\t\t\tresult += \".\"\n \t\t\t}\n-\t\t\tvar al int\n-\t\t\tfor range a {\n-\t\t\t\tal++\n+\t\t}\n+\t\tresult += \",\" + centsStr[len(centsStr)-2:]\n+\t\tif negative {\n+\t\t\tresult += \"-\"\n+\t\t} else {\n+\t\t\tresult += \" \"\n+\t\t}\n+\t} else if locale == \"en-US\" {\n+\t\tif negative {\n+\t\t\tresult += \"(\"\n+\t\t}\n+\t\tif currency == \"EUR\" {\n+\t\t\tresult += \"\u20ac\"\n+\t\t} else if currency == \"USD\" {\n+\t\t\tresult += \"$\"\n+\t\t} else {\n+\t\t\treturn \"\", errors.New(\"invalid currency\")\n+\t\t}\n+\n+\t\tvar parts []string\n+\t\tfor len(intPart) > 3 {\n+\t\t\tparts = append(parts, intPart[len(intPart)-3:])\n+\t\t\tintPart = intPart[:len(intPart)-3]\n+\t\t}\n+\t\tif len(intPart) > 0 {\n+\t\t\tparts = append(parts, intPart)\n+\t\t}\n+\t\tfor i := len(parts) - 1; i >= 0; i-- {\n+\t\t\tresult += parts[i]\n+\t\t\tif i > 0 {\n+\t\t\t\tresult += \",\"\n \t\t\t}\n-\t\t\tco <- struct {\n-\t\t\t\ti int\n-\t\t\t\ts string\n-\t\t\t\te error\n-\t\t\t}{i: i, s: d + strings.Repeat(\" \", 10-len(d)) + \" | \" + de + \" | \" +\n-\t\t\t\tstrings.Repeat(\" \", 13-al) + a + \"\\n\"}\n-\t\t}(i, et)\n-\t}\n-\tss := make([]string, len(entriesCopy))\n-\tfor range entriesCopy {\n-\t\tv := <-co\n-\t\tif v.e != nil {\n-\t\t\treturn \"\", v.e\n \t\t}\n-\t\tss[v.i] = v.s\n+\t\tresult += \".\" + centsStr[len(centsStr)-2:]\n+\t\tif negative {\n+\t\t\tresult += \")\"\n+\t\t} else {\n+\t\t\tresult += \" \"\n+\t\t}\n+\t} else {\n+\t\treturn \"\", errors.New(\"invalid locale\")\n+\t}\n+\n+\treturn result, nil\n+}\n+\n+// padRight pads the string s on the right with spaces to ensure it has at least n characters.\n+func padRight(s string, n int) string {\n+\tif len(s) < n {\n+\t\treturn s + strings.Repeat(\" \", n-len(s))\n \t}\n-\tfor i := 0; i < len(entriesCopy); i++ {\n-\t\ts += ss[i]\n+\treturn s\n+}\n+\n+// padLeft pads the string s on the left with spaces to ensure it has at least n characters.\n+func padLeft(s string, n int) string {\n+\tif len(s) < n {\n+\t\treturn strings.Repeat(\" \", n-len(s)) + s\n \t}\n-\treturn s, nil\n+\treturn s\n }\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}