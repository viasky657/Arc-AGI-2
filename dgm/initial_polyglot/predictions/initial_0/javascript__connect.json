{
    "instance_id": "javascript__connect",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/connect.js b/connect.js\nindex c27a6b8..d0f9570 100644\n--- a/connect.js\n+++ b/connect.js\n@@ -1,14 +1,81 @@\n //\n-// This is only a SKELETON file for the 'Connect' exercise. It's been provided as a\n-// convenience to get you started writing code faster.\n+// This is the solution for the 'Connect' exercise.\n+// It computes the result of a game of Hex/Polygon (CON-TAC-TIX).\n //\n+// The board is provided as a string with newline-separated rows. In each row, only the tokens 'X', 'O', and '.' are significant.\n+// Player O is trying to connect the top and bottom, while Player X is trying to connect the left and right.\n+// Note: In the board representation provided, spaces might be used for alignment. They are removed.\n \n export class Board {\n-  constructor() {\n-    throw new Error('Remove this statement and implement this function');\n+  constructor(board) {\n+    // The board argument is expected to be a string with newline-delimited rows.\n+    // Remove any leading/trailing whitespace and remove spaces in each row.\n+    this.grid = board.trim().split('\\n').map(line => line.replace(/\\s+/g, ''));\n+    this.n = this.grid.length;\n+    this.m = this.n > 0 ? this.grid[0].length : 0;\n+  }\n+\n+  // Helper function: perform DFS on the board given a starting set of cells and target condition checker.\n+  _dfs(startCells, token, targetCondition) {\n+    const directions = [\n+      [-1, 0],\n+      [-1, 1],\n+      [0, -1],\n+      [0, 1],\n+      [1, -1],\n+      [1, 0]\n+    ];\n+    const visited = Array.from({ length: this.n }, () => Array(this.m).fill(false));\n+    const stack = [...startCells];\n+    for (const [i, j] of startCells) {\n+      visited[i][j] = true;\n+    }\n+\n+    while (stack.length) {\n+      const [i, j] = stack.pop();\n+      if (targetCondition(i, j)) {\n+        return true;\n+      }\n+      for (const [di, dj] of directions) {\n+        const ni = i + di;\n+        const nj = j + dj;\n+        if (ni >= 0 && ni < this.n && nj >= 0 && nj < this.m && !visited[ni][nj] && this.grid[ni][nj] === token) {\n+          visited[ni][nj] = true;\n+          stack.push([ni, nj]);\n+        }\n+      }\n+    }\n+    return false;\n   }\n \n   winner() {\n-    throw new Error('Remove this statement and implement this function');\n+    // For player O, the goal is to connect top (row 0) to bottom (row n-1).\n+    // Find all 'O's in the top row.\n+    const startO = [];\n+    for (let j = 0; j < this.m; j++) {\n+      if (this.grid[0][j] === 'O') {\n+        startO.push([0, j]);\n+      }\n+    }\n+    const oWins = this._dfs(startO, 'O', (i, j) => i === this.n - 1);\n+\n+    // For player X, the goal is to connect left (column 0) to right (column m-1).\n+    const startX = [];\n+    for (let i = 0; i < this.n; i++) {\n+      if (this.grid[i][0] === 'X') {\n+        startX.push([i, 0]);\n+      }\n+    }\n+    const xWins = this._dfs(startX, 'X', (i, j) => j === this.m - 1);\n+\n+    // According to the game rules, only one player can win in a valid game.\n+    // In case of an invalid board where both conditions meet, we return the player who achieved their connection.\n+    if (oWins && !xWins) {\n+      return 'O';\n+    } else if (xWins && !oWins) {\n+      return 'X';\n+    } else {\n+      return 'None';\n+    }\n   }\n }\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}