{
    "instance_id": "cpp__perfect-numbers",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/perfect_numbers.cpp b/perfect_numbers.cpp\nindex 221b003..317ad9c 100644\n--- a/perfect_numbers.cpp\n+++ b/perfect_numbers.cpp\n@@ -1,3 +1,36 @@\n #include \"perfect_numbers.h\"\n+#include <cmath>\n \n-namespace perfect_numbers {}  // namespace perfect_numbers\n+namespace perfect_numbers {\n+\n+int aliquot_sum(int n) {\n+    if (n <= 1) {\n+        return 0;\n+    }\n+    int sum = 1; // 1 is always a divisor for any number > 1\n+    int sqrt_n = static_cast<int>(std::sqrt(n));\n+    for (int i = 2; i <= sqrt_n; ++i) {\n+        if (n % i == 0) {\n+            int other = n / i;\n+            if (i == other) {\n+                sum += i;\n+            } else {\n+                sum += i + other;\n+            }\n+        }\n+    }\n+    return sum;\n+}\n+\n+number_type classify(int n) {\n+    int sum = aliquot_sum(n);\n+    if (sum == n) {\n+        return number_type::Perfect;\n+    } else if (sum > n) {\n+        return number_type::Abundant;\n+    } else {\n+        return number_type::Deficient;\n+    }\n+}\n+\n+}  // namespace perfect_numbers\ndiff --git a/perfect_numbers.h b/perfect_numbers.h\nindex e97d027..4f2faf0 100644\n--- a/perfect_numbers.h\n+++ b/perfect_numbers.h\n@@ -1,6 +1,26 @@\n #if !defined(PERFECT_NUMBERS_H)\n #define PERFECT_NUMBERS_H\n \n-namespace perfect_numbers {}  // namespace perfect_numbers\n+namespace perfect_numbers {\n \n-#endif  // PERFECT_NUMBERS_H\n\\ No newline at end of file\n+// Classification types as per Nicomachus\n+// Perfect: number equals its aliquot sum\n+// Abundant: aliquot sum is greater than the number\n+// Deficient: aliquot sum is less than the number\n+\n+enum class number_type {\n+    Perfect,\n+    Abundant,\n+    Deficient\n+};\n+\n+// Returns the aliquot sum (sum of proper divisors excluding the number itself) of n\n+// For n <= 1, returns 0\n+int aliquot_sum(int n);\n+\n+// Classifies a positive integer as Perfect, Abundant, or Deficient\n+number_type classify(int n);\n+\n+}  // namespace perfect_numbers\n+\n+#endif  // PERFECT_NUMBERS_H\ndiff --git a/test/tests-main.cpp b/test/tests-main.cpp\nindex 0c7c351..d355251 100644\n--- a/test/tests-main.cpp\n+++ b/test/tests-main.cpp\n@@ -1,2 +1,45 @@\n #define CATCH_CONFIG_MAIN\n #include \"catch.hpp\"\n+\n+#include \"../perfect_numbers.h\"\n+\n+TEST_CASE(\"Aliquot Sum Calculation\", \"[aliquot_sum]\") {\n+    // For n <= 1, aliquot sum should be 0\n+    REQUIRE(perfect_numbers::aliquot_sum(0) == 0);\n+    REQUIRE(perfect_numbers::aliquot_sum(1) == 0);\n+\n+    // For 6, proper divisors are 1, 2, 3, sum = 6\n+    REQUIRE(perfect_numbers::aliquot_sum(6) == 6);\n+\n+    // For 15, proper divisors are 1, 3, 5, sum = 9\n+    REQUIRE(perfect_numbers::aliquot_sum(15) == 9);\n+\n+    // For prime number like 7, only proper divisor is 1\n+    REQUIRE(perfect_numbers::aliquot_sum(7) == 1);\n+\n+    // For 28, proper divisors: 1, 2, 4, 7, 14, sum = 28\n+    REQUIRE(perfect_numbers::aliquot_sum(28) == 28);\n+\n+    // For 12, proper divisors: 1, 2, 3, 4, 6, sum = 16\n+    REQUIRE(perfect_numbers::aliquot_sum(12) == 16);\n+}\n+\n+TEST_CASE(\"Classification of numbers\", \"[classify]\") {\n+    // 6 is Perfect: aliquot sum = 6\n+    REQUIRE(perfect_numbers::classify(6) == perfect_numbers::number_type::Perfect);\n+\n+    // 28 is Perfect: aliquot sum = 28\n+    REQUIRE(perfect_numbers::classify(28) == perfect_numbers::number_type::Perfect);\n+\n+    // 12 is Abundant: aliquot sum = 16 > 12\n+    REQUIRE(perfect_numbers::classify(12) == perfect_numbers::number_type::Abundant);\n+\n+    // 24 is Abundant: aliquot sum = 36 > 24\n+    REQUIRE(perfect_numbers::classify(24) == perfect_numbers::number_type::Abundant);\n+\n+    // 8 is Deficient: aliquot sum = 7 < 8\n+    REQUIRE(perfect_numbers::classify(8) == perfect_numbers::number_type::Deficient);\n+\n+    // 7 is Deficient (prime): aliquot sum = 1 < 7\n+    REQUIRE(perfect_numbers::classify(7) == perfect_numbers::number_type::Deficient);\n+}\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}