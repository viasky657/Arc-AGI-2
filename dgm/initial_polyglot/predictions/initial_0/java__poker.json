{
    "instance_id": "java__poker",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/src/main/java/Poker.java b/src/main/java/Poker.java\nindex c6ed7e8..3afd47b 100644\n--- a/src/main/java/Poker.java\n+++ b/src/main/java/Poker.java\n@@ -1,13 +1,272 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n \n class Poker {\n \n-    Poker(List<String> hand) {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n+    // Internal class to hold evaluated hand information\n+    private static class EvaluatedHand {\n+        String handStr;\n+        int category; // higher is better\n+        List<Integer> tieBreaker; // list of integers to break ties\n+\n+        EvaluatedHand(String handStr, int category, List<Integer> tieBreaker) {\n+            this.handStr = handStr;\n+            this.category = category;\n+            this.tieBreaker = tieBreaker;\n+        }\n+\n+        // Compare two evaluated hands\n+        // Returns positive if this hand beats other\n+        public int compareTo(EvaluatedHand other) {\n+            if (this.category != other.category) {\n+                return this.category - other.category;\n+            }\n+            // Compare tie breaker lists lexicographically\n+            int size = Math.min(this.tieBreaker.size(), other.tieBreaker.size());\n+            for (int i = 0; i < size; i++) {\n+                int cmp = this.tieBreaker.get(i) - other.tieBreaker.get(i);\n+                if (cmp != 0) {\n+                    return cmp;\n+                }\n+            }\n+            return 0;\n+        }\n+    }\n+\n+    private List<String> hands;\n+    private List<EvaluatedHand> evaluatedHands;\n+\n+    public Poker(List<String> hands) {\n+        this.hands = hands;\n+        this.evaluatedHands = new ArrayList<>();\n+        for (String hand : hands) {\n+            evaluatedHands.add(evaluateHand(hand));\n+        }\n+    }\n+\n+    public List<String> getBestHands() {\n+        if (evaluatedHands.isEmpty()) {\n+            return new ArrayList<>();\n+        }\n+\n+        // Determine the best evaluated hand value\n+        EvaluatedHand best = evaluatedHands.get(0);\n+        for (EvaluatedHand eh : evaluatedHands) {\n+            if (eh.compareTo(best) > 0) {\n+                best = eh;\n+            }\n+        }\n+\n+        // Collect all hands that tie with best\n+        List<String> bestHands = new ArrayList<>();\n+        for (EvaluatedHand eh : evaluatedHands) {\n+            if (eh.compareTo(best) == 0) {\n+                bestHands.add(eh.handStr);\n+            }\n+        }\n+\n+        return bestHands;\n+    }\n+\n+    // Evaluate a single hand (given as a string) and return its category and tie-breaker info\n+    private EvaluatedHand evaluateHand(String handStr) {\n+        // Split hand string by whitespace. In case there is a player label ending with ':' skip that token.\n+        String[] tokens = handStr.trim().split(\"\\\\s+\");\n+        List<String> cardStrs = new ArrayList<>();\n+        for (String token : tokens) {\n+            if (token.endsWith(\":\")) {\n+                continue; // skip player name label\n+            }\n+            cardStrs.add(token);\n+        }\n+\n+        if (cardStrs.size() != 5) {\n+            throw new IllegalArgumentException(\"Hand must consist of 5 cards: \" + handStr);\n+        }\n+\n+        int[] ranks = new int[5];\n+        char[] suits = new char[5];\n+        for (int i = 0; i < 5; i++) {\n+            String card = cardStrs.get(i);\n+            ranks[i] = rankCharToValue(card.charAt(0));\n+            suits[i] = card.charAt(1);\n+        }\n+\n+        // Check for flush: all suits same\n+        boolean flush = true;\n+        for (int i = 1; i < suits.length; i++) {\n+            if (suits[i] != suits[0]) {\n+                flush = false;\n+                break;\n+            }\n+        }\n+\n+        // Sort ranks for further evaluation\n+        Integer[] sortedRanks = new Integer[5];\n+        for (int i = 0; i < 5; i++) {\n+            sortedRanks[i] = ranks[i];\n+        }\n+        Arrays.sort(sortedRanks, Collections.reverseOrder());\n+        List<Integer> sortedRanksList = Arrays.asList(sortedRanks);\n+\n+        // Check for straight\n+        boolean straight = isStraight(sortedRanksList);\n+        int straightHighCard = getStraightHighCard(sortedRanksList);\n+\n+        // Frequency count for ranks\n+        Map<Integer, Integer> freq = new HashMap<>();\n+        for (int rank : ranks) {\n+            freq.put(rank, freq.getOrDefault(rank, 0) + 1);\n+        }\n+\n+        // Create lists for groups\n+        List<int[]> groups = new ArrayList<>();\n+        // Each int[] is {frequency, rank}\n+        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {\n+            groups.add(new int[]{entry.getValue(), entry.getKey()});\n+        }\n+\n+        // Sort groups: first by frequency descending, then by rank descending\n+        Collections.sort(groups, new Comparator<int[]>() {\n+            public int compare(int[] a, int[] b) {\n+                if (a[0] != b[0]) {\n+                    return b[0] - a[0];\n+                } else {\n+                    return b[1] - a[1];\n+                }\n+            }\n+        });\n+\n+        int category = -1;\n+        List<Integer> tieBreaker = new ArrayList<>();\n+\n+        // Check hand categories\n+        if (straight && flush) {\n+            // Straight flush\n+            category = 8;\n+            tieBreaker.add(straightHighCard);\n+        } else if (groups.get(0)[0] == 4) {\n+            // Four of a kind\n+            category = 7;\n+            tieBreaker.add(groups.get(0)[1]);\n+            // kicker: the card that is not four-of-a-kind\n+            for (int[] group : groups) {\n+                if (group[0] == 1) {\n+                    tieBreaker.add(group[1]);\n+                }\n+            }\n+        } else if (groups.get(0)[0] == 3 && groups.size() == 2) {\n+            // Full house: three-of-a-kind and a pair\n+            category = 6;\n+            tieBreaker.add(groups.get(0)[1]); // three of a kind rank\n+            tieBreaker.add(groups.get(1)[1]); // pair rank\n+        } else if (flush) {\n+            // Flush\n+            category = 5;\n+            tieBreaker.addAll(sortedRanksList);\n+        } else if (straight) {\n+            // Straight\n+            category = 4;\n+            tieBreaker.add(straightHighCard);\n+        } else if (groups.get(0)[0] == 3) {\n+            // Three of a kind\n+            category = 3;\n+            tieBreaker.add(groups.get(0)[1]);\n+            // Add kickers in descending order\n+            List<Integer> kickers = new ArrayList<>();\n+            for (int[] group : groups) {\n+                if (group[0] == 1) {\n+                    kickers.add(group[1]);\n+                }\n+            }\n+            Collections.sort(kickers, Collections.reverseOrder());\n+            tieBreaker.addAll(kickers);\n+        } else if (groups.get(0)[0] == 2 && groups.size() == 3) {\n+            // Two pair: there will be two pairs and one kicker since groups: 2,2,1\n+            category = 2;\n+            // Sort pairs descending\n+            List<Integer> pairs = new ArrayList<>();\n+            int kicker = -1;\n+            for (int[] group : groups) {\n+                if (group[0] == 2) {\n+                    pairs.add(group[1]);\n+                } else {\n+                    kicker = group[1];\n+                }\n+            }\n+            Collections.sort(pairs, Collections.reverseOrder());\n+            tieBreaker.addAll(pairs);\n+            tieBreaker.add(kicker);\n+        } else if (groups.get(0)[0] == 2 && groups.size() == 4) {\n+            // One pair: one pair and three kickers\n+            category = 1;\n+            tieBreaker.add(groups.get(0)[1]);\n+            List<Integer> kickers = new ArrayList<>();\n+            for (int[] group : groups) {\n+                if (group[0] == 1) {\n+                    kickers.add(group[1]);\n+                }\n+            }\n+            Collections.sort(kickers, Collections.reverseOrder());\n+            tieBreaker.addAll(kickers);\n+        } else {\n+            // High card\n+            category = 0;\n+            tieBreaker.addAll(sortedRanksList);\n+        }\n+\n+        return new EvaluatedHand(handStr, category, tieBreaker);\n+    }\n+\n+    private boolean isStraight(List<Integer> sortedRanksDesc) {\n+        // Check normal straight\n+        for (int i = 0; i < sortedRanksDesc.size() - 1; i++) {\n+            if (sortedRanksDesc.get(i) - sortedRanksDesc.get(i + 1) != 1) {\n+                // Check special case: wheel straight: A,5,4,3,2\n+                if (i == 0 && sortedRanksDesc.get(0) == 14 && sortedRanksDesc.get(1) == 5) {\n+                    // continue checking for 5,4,3,2\n+                    continue;\n+                }\n+                return false;\n+            }\n+        }\n+        // Additionally, check for wheel straight properly\n+        if (sortedRanksDesc.equals(Arrays.asList(14, 5, 4, 3, 2))) {\n+            return true;\n+        }\n+        return true;\n+    }\n+\n+    private int getStraightHighCard(List<Integer> sortedRanksDesc) {\n+        // For wheel straight, the high card is 5\n+        if (sortedRanksDesc.equals(Arrays.asList(14, 5, 4, 3, 2))) {\n+            return 5;\n+        }\n+        return sortedRanksDesc.get(0);\n     }\n \n-    List<String> getBestHands() {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n+    private int rankCharToValue(char rankChar) {\n+        switch (rankChar) {\n+            case '2': return 2;\n+            case '3': return 3;\n+            case '4': return 4;\n+            case '5': return 5;\n+            case '6': return 6;\n+            case '7': return 7;\n+            case '8': return 8;\n+            case '9': return 9;\n+            case 'T': return 10;\n+            case 'J': return 11;\n+            case 'Q': return 12;\n+            case 'K': return 13;\n+            case 'A': return 14;\n+            default: throw new IllegalArgumentException(\"Invalid rank character: \" + rankChar);\n+        }\n     }\n \n-}\n\\ No newline at end of file\n+}\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}