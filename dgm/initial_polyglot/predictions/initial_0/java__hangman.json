{
    "instance_id": "java__hangman",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/src/main/java/Hangman.java b/src/main/java/Hangman.java\nindex abab324..841f8ff 100644\n--- a/src/main/java/Hangman.java\n+++ b/src/main/java/Hangman.java\n@@ -1,9 +1,99 @@\n import io.reactivex.Observable;\n \n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n class Hangman {\n \n+    // Define the parts of the hangman in order\n+    private static final Part[] PARTS = {Part.HEAD, Part.BODY, Part.LEFT_ARM, Part.RIGHT_ARM, Part.LEFT_LEG, Part.RIGHT_LEG};\n+    private static final int MAX_MISSES = PARTS.length;\n+\n+    // Internal state for a game\n+    private static class GameState {\n+        final String secret;\n+        final Set<String> guesses;\n+        final Set<String> misses;\n+\n+        GameState(String secret) {\n+            this.secret = secret;\n+            this.guesses = new LinkedHashSet<>();\n+            this.misses = new LinkedHashSet<>();\n+        }\n+\n+        GameState(String secret, Set<String> guesses, Set<String> misses) {\n+            this.secret = secret;\n+            this.guesses = guesses;\n+            this.misses = misses;\n+        }\n+\n+        // Process a new guess (letter) and return a new GameState with updated values\n+        GameState makeGuess(String letter) {\n+            // If already guessed, return current state\n+            if (guesses.contains(letter)) {\n+                return this;\n+            }\n+            Set<String> newGuesses = new LinkedHashSet<>(guesses);\n+            newGuesses.add(letter);\n+            Set<String> newMisses = new LinkedHashSet<>(misses);\n+            if (!secret.contains(letter)) {\n+                newMisses.add(letter);\n+            }\n+            return new GameState(secret, newGuesses, newMisses);\n+        }\n+\n+        // Build the discovered string: show correct guessed letters and underscores for missing ones\n+        String discovered() {\n+            StringBuilder sb = new StringBuilder();\n+            for (char c : secret.toCharArray()) {\n+                String letter = String.valueOf(c);\n+                if (guesses.contains(letter)) {\n+                    sb.append(letter);\n+                } else {\n+                    sb.append(\"_\");\n+                }\n+            }\n+            return sb.toString();\n+        }\n+\n+        // Compute the list of hangman parts based on the number of misses\n+        List<Part> parts() {\n+            int count = misses.size();\n+            List<Part> partsList = new ArrayList<>();\n+            for (int i = 0; i < count && i < PARTS.length; i++) {\n+                partsList.add(PARTS[i]);\n+            }\n+            return partsList;\n+        }\n+\n+        // Determine the game status: win if discovered equals secret, lose if too many misses, else in progress\n+        Status status() {\n+            if (discovered().equals(secret)) {\n+                return Status.WIN;\n+            }\n+            if (misses.size() >= MAX_MISSES) {\n+                return Status.LOSE;\n+            }\n+            return Status.IN_PROGRESS;\n+        }\n+\n+        // Convert the game state to an Output instance\n+        Output toOutput() {\n+            return new Output(secret, discovered(), guesses, misses, parts(), status());\n+        }\n+    }\n+\n+    // The play method uses the provided observables for words (new game words) and letters (guesses)\n+    // Each time a new word is received the game starts over, accepting letter guesses and emitting Output updates.\n     Observable<Output> play(Observable<String> words, Observable<String> letters) {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n+        return words.switchMap(word -> {\n+            GameState init = new GameState(word);\n+            return letters.scan(init, (state, letter) -> state.makeGuess(letter))\n+                          .startWith(init)\n+                          .map(GameState::toOutput);\n+        });\n     }\n \n-}\n\\ No newline at end of file\n+}\ndiff --git a/src/main/java/Part.java b/src/main/java/Part.java\nnew file mode 100644\nindex 0000000..d1d54e6\n--- /dev/null\n+++ b/src/main/java/Part.java\n@@ -0,0 +1,8 @@\n+enum Part {\n+    HEAD,\n+    BODY,\n+    LEFT_ARM,\n+    RIGHT_ARM,\n+    LEFT_LEG,\n+    RIGHT_LEG\n+}\ndiff --git a/src/main/java/Status.java b/src/main/java/Status.java\nnew file mode 100644\nindex 0000000..0cfe00b\n--- /dev/null\n+++ b/src/main/java/Status.java\n@@ -0,0 +1,5 @@\n+enum Status {\n+    WIN,\n+    LOSE,\n+    IN_PROGRESS\n+}\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}