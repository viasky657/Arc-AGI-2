{
    "instance_id": "cpp__robot-name",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/robot_name.cpp b/robot_name.cpp\nindex bee6050..a8b6c21 100644\n--- a/robot_name.cpp\n+++ b/robot_name.cpp\n@@ -1,5 +1,70 @@\n #include \"robot_name.h\"\n \n+#include <random>\n+#include <unordered_set>\n+#include <string>\n+\n+namespace {\n+    // Global set storing the names of all robots currently in use.\n+    std::unordered_set<std::string> usedNames;\n+}\n+\n namespace robot_name {\n \n+// Check if a name is already used.\n+bool Robot::isNameUsed(const std::string &name) {\n+    return usedNames.find(name) != usedNames.end();\n+}\n+\n+// Add a name to the used names set.\n+void Robot::addName(const std::string &name) {\n+    usedNames.insert(name);\n+}\n+\n+// Remove a name from the used names set.\n+void Robot::removeName(const std::string &name) {\n+    usedNames.erase(name);\n+}\n+\n+// Generate a random robot name that is not already used.\n+std::string Robot::generateName() {\n+    static std::random_device rd;\n+    static std::mt19937 gen(rd());\n+    std::uniform_int_distribution<> letterDist(0, 25);\n+    std::uniform_int_distribution<> digitDist(0, 9);\n+    \n+    std::string name;\n+    // Generate names until a unique one is found\n+    do {\n+        name.clear();\n+        name.push_back('A' + letterDist(gen));\n+        name.push_back('A' + letterDist(gen));\n+        name.push_back('0' + digitDist(gen));\n+        name.push_back('0' + digitDist(gen));\n+        name.push_back('0' + digitDist(gen));\n+    } while (isNameUsed(name));\n+    \n+    return name;\n+}\n+\n+// Robot constructor. The robot comes with no name (factory reset state).\n+Robot::Robot() : robotName(\"\") {}\n+\n+// Returns the robot's name. If the robot does not have a name, a new one is generated and registered.\n+std::string Robot::name() {\n+    if (robotName.empty()) {\n+        robotName = generateName();\n+        addName(robotName);\n+    }\n+    return robotName;\n+}\n+\n+// Resets the robot to factory settings. Removes the robot's current name from the global store.\n+void Robot::reset() {\n+    if (!robotName.empty()) {\n+        removeName(robotName);\n+        robotName.clear();\n+    }\n+}\n+\n }  // namespace robot_name\ndiff --git a/robot_name.h b/robot_name.h\nindex 23aaf1e..4c465d2 100644\n--- a/robot_name.h\n+++ b/robot_name.h\n@@ -1,8 +1,30 @@\n-#if !defined(ROBOT_NAME_H)\n+#ifndef ROBOT_NAME_H\n #define ROBOT_NAME_H\n \n+#include <string>\n+\n namespace robot_name {\n \n+class Robot {\n+public:\n+    Robot();\n+\n+    // Returns the robot's name. Generates a new one if none exists.\n+    std::string name();\n+\n+    // Resets the robot to factory settings. The next call to name() will generate a new name.\n+    void reset();\n+\n+private:\n+    std::string robotName;\n+\n+    // Helper functions for name generation and tracking uniqueness\n+    static std::string generateName();\n+    static bool isNameUsed(const std::string &name);\n+    static void addName(const std::string &name);\n+    static void removeName(const std::string &name);\n+};\n+\n }  // namespace robot_name\n \n-#endif // ROBOT_NAME_H\n\\ No newline at end of file\n+#endif // ROBOT_NAME_H\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}