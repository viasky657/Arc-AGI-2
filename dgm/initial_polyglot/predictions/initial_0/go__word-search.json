{
    "instance_id": "go__word-search",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/word_search.go b/word_search.go\nindex c0e26bd..497db1d 100644\n--- a/word_search.go\n+++ b/word_search.go\n@@ -1,5 +1,64 @@\n package wordsearch\n \n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+// Solve finds each word in the puzzle and returns a map from the word to a pair of coordinates:\n+// the first coordinate is the location of the first letter and the second coordinate is the location of the last letter.\n+// Coordinates are given as row and column, both starting at 1.\n+// The search checks all eight directions: horizontal (left-to-right, right-to-left), vertical (top-to-bottom, bottom-to-top), and the four diagonals.\n+\n func Solve(words []string, puzzle []string) (map[string][2][2]int, error) {\n-\tpanic(\"Please implement the Solve function\")\n+\tresult := make(map[string][2][2]int)\n+\trows := len(puzzle)\n+\tif rows == 0 {\n+\t\treturn result, nil\n+\t}\n+\tcols := len(puzzle[0])\n+\t\n+\t// All eight possible directions: (dr, dc)\n+\tdirections := [][2]int{\n+\t\t{-1, -1}, {-1, 0}, {-1, 1},\n+\t\t{0, -1},           {0, 1},\n+\t\t{1, -1},  {1, 0},  {1, 1},\n+\t}\n+\t\n+\t// For each word, search the puzzle\n+\tfor _, word := range words {\n+\t\tfound := false\n+\t\tfor r := 0; r < rows && !found; r++ {\n+\t\t\tfor c := 0; c < cols && !found; c++ {\n+\t\t\t\tif puzzle[r][c] != word[0] {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\t// Try every direction from this starting point\n+\t\t\t\tfor _, d := range directions {\n+\t\t\t\t\tdr, dc := d[0], d[1]\n+\t\t\t\t\tmatch := true\n+\t\t\t\t\tfor i := 0; i < len(word); i++ {\n+\t\t\t\t\t\tnr := r + dr*i\n+\t\t\t\t\t\tnc := c + dc*i\n+\t\t\t\t\t\tif nr < 0 || nr >= rows || nc < 0 || nc >= cols || puzzle[nr][nc] != word[i] {\n+\t\t\t\t\t\t\tmatch = false\n+\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif match {\n+\t\t\t\t\t\t// Coordinates are 1-indexed\n+\t\t\t\t\t\tstart := [2]int{r + 1, c + 1}\n+\t\t\t\t\t\tend := [2]int{r + dr*(len(word)-1) + 1, c + dc*(len(word)-1) + 1}\n+\t\t\t\t\t\tresult[word] = [2][2]int{start, end}\n+\t\t\t\t\t\tfound = true\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif !found {\n+\t\t\treturn nil, errors.New(fmt.Sprintf(\"word %s not found\", word))\n+\t\t}\n+\t}\n+\treturn result, nil\n }\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}