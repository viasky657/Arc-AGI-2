{
    "instance_id": "cpp__yacht",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/yacht.cpp b/yacht.cpp\nindex 47c8192..87d6032 100644\n--- a/yacht.cpp\n+++ b/yacht.cpp\n@@ -1,5 +1,88 @@\n #include \"yacht.h\"\n+#include <algorithm>\n+#include <numeric>\n+#include <map>\n+#include <vector>\n \n namespace yacht {\n \n+int score(const std::vector<int>& dice, Category category) {\n+    // Calculate the sum of all dice\n+    int sum = std::accumulate(dice.begin(), dice.end(), 0);\n+\n+    // Count frequencies of dice faces\n+    std::map<int, int> counts;\n+    for (int d : dice) {\n+        counts[d]++;\n+    }\n+\n+    switch (category) {\n+        case Category::Ones:\n+        case Category::Twos:\n+        case Category::Threes:\n+        case Category::Fours:\n+        case Category::Fives:\n+        case Category::Sixes: {\n+            // For these categories, the enum value ordering is assumed to be Ones = 0, Twos = 1, etc.\n+            int face = static_cast<int>(category) + 1;\n+            return counts[face] * face;\n+        }\n+        \n+        case Category::FullHouse: {\n+            // Full house: two distinct numbers, one occurs thrice and the other twice\n+            if (counts.size() == 2) {\n+                bool hasThree = false;\n+                bool hasTwo = false;\n+                for (const auto &p : counts) {\n+                    if (p.second == 3) hasThree = true;\n+                    else if (p.second == 2) hasTwo = true;\n+                }\n+                if (hasThree && hasTwo) return sum;\n+            }\n+            return 0;\n+        }\n+        \n+        case Category::FourOfAKind: {\n+            // Four of a kind: at least one dice appears 4 or 5 times\n+            for (const auto &p : counts) {\n+                if (p.second >= 4) {\n+                    return p.first * 4; // count only four dice\n+                }\n+            }\n+            return 0;\n+        }\n+        \n+        case Category::LittleStraight: {\n+            // Little straight: dice must be 1,2,3,4,5\n+            std::vector<int> d = dice;\n+            std::sort(d.begin(), d.end());\n+            std::vector<int> target {1,2,3,4,5};\n+            if (d == target) return 30;\n+            return 0;\n+        }\n+        \n+        case Category::BigStraight: {\n+            // Big straight: dice must be 2,3,4,5,6\n+            std::vector<int> d = dice;\n+            std::sort(d.begin(), d.end());\n+            std::vector<int> target {2,3,4,5,6};\n+            if (d == target) return 30;\n+            return 0;\n+        }\n+        \n+        case Category::Choice: {\n+            // Choice: simply the sum of dice\n+            return sum;\n+        }\n+        \n+        case Category::Yacht: {\n+            // Yacht: all dice must be identical\n+            if (counts.size() == 1) return 50;\n+            return 0;\n+        }\n+    }\n+    \n+    return 0; // default\n+}\n+\n }  // namespace yacht\ndiff --git a/yacht.h b/yacht.h\nindex cd205f1..9622176 100644\n--- a/yacht.h\n+++ b/yacht.h\n@@ -1,5 +1,23 @@\n #pragma once\n+#include <vector>\n \n namespace yacht {\n \n+    enum class Category {\n+        Ones,\n+        Twos,\n+        Threes,\n+        Fours,\n+        Fives,\n+        Sixes,\n+        FullHouse,\n+        FourOfAKind,\n+        LittleStraight,\n+        BigStraight,\n+        Choice,\n+        Yacht\n+    };\n+\n+    int score(const std::vector<int>& dice, Category category);\n+\n }  // namespace yacht\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}