{
    "instance_id": "go__alphametics",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/alphametics.go b/alphametics.go\nindex fa04bde..f058d99 100644\n--- a/alphametics.go\n+++ b/alphametics.go\n@@ -1,5 +1,143 @@\n package alphametics\n \n+import (\n+\t\"errors\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n func Solve(puzzle string) (map[string]int, error) {\n-\tpanic(\"Please implement the Solve function\")\n+\t// Split the puzzle around \"==\" to separate left and right parts\n+\tparts := strings.Split(puzzle, \"==\")\n+\tif len(parts) != 2 {\n+\t\treturn nil, errors.New(\"puzzle must contain exactly one '==' operator\")\n+\t}\n+\n+\tleftPart := strings.TrimSpace(parts[0])\n+\trightPart := strings.TrimSpace(parts[1])\n+\n+\t// Left part may be an addition of multiple words separated by '+'\n+\tleftWords := strings.Split(leftPart, \"+\")\n+\tfor i, word := range leftWords {\n+\t\tleftWords[i] = strings.TrimSpace(word)\n+\t}\n+\n+\t// Right word\n+\trightWord := rightPart\n+\n+\t// Collect all words\n+\twords := make([]string, 0, len(leftWords)+1)\n+\twords = append(words, leftWords...)\n+\twords = append(words, rightWord)\n+\n+\t// Collect all unique letters and track those that cannot be zero (leading letters of multi-digit words)\n+\tletterSet := make(map[rune]bool)\n+\tnonZero := make(map[rune]bool)\n+\n+\tfor _, word := range words {\n+\t\tif len(word) > 0 {\n+\t\t\tfor i, ch := range word {\n+\t\t\t\tletterSet[ch] = true\n+\t\t\t\tif i == 0 && len(word) > 1 {\n+\t\t\t\t\tnonZero[ch] = true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Convert set to slice\n+\tletters := make([]rune, 0, len(letterSet))\n+\tfor letter := range letterSet {\n+\t\tletters = append(letters, letter)\n+\t}\n+\n+\tif len(letters) > 10 {\n+\t\treturn nil, errors.New(\"more than 10 unique letters, no solution possible\")\n+\t}\n+\n+\t// Prepare a slice of digits 0-9\n+\tdigits := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n+\n+\t// We'll use backtracking to try assignments, we assign letters[0..n-1] with some digits\n+\tassignment := make(map[rune]int)\n+\n+\tvar solveRecursive func(idx int) bool\n+\tsolveRecursive = func(idx int) bool {\n+\t\tif idx == len(letters) {\n+\t\t\t// Check leading zero condition\n+\t\t\tfor _, word := range words {\n+\t\t\t\tif len(word) > 1 {\n+\t\t\t\t\tfirst := rune(word[0])\n+\t\t\t\t\tif assignment[first] == 0 {\n+\t\t\t\t\t\treturn false\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// Evaluate the sum of left words and check against right word\n+\t\t\tleftSum := 0\n+\t\t\tfor _, word := range leftWords {\n+\t\t\t\tnum, err := wordToNumber(word, assignment)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t\tleftSum += num\n+\t\t\t}\n+\n+\t\t\trightNum, err := wordToNumber(rightWord, assignment)\n+\t\t\tif err != nil {\n+\t\t\t\treturn false\n+\t\t\t}\n+\n+\t\t\tif leftSum == rightNum {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t\treturn false\n+\t\t}\n+\n+\t\t// Try every digit for current letter, ensuring uniqueness\n+\t\tfor i := idx; i < len(digits); i++ {\n+\t\t\tdigits[idx], digits[i] = digits[i], digits[idx] // swap\n+\t\t\tassignment[letters[idx]] = digits[idx]\n+\t\t\t// Early check: if letter is a leading letter, it must not be 0\n+\t\t\tif nonZero[letters[idx]] && digits[idx] == 0 {\n+\t\t\t\t// Swap back\n+\t\t\t\tdigits[idx], digits[i] = digits[i], digits[idx]\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif solveRecursive(idx + 1) {\n+\t\t\t\treturn true\n+\t\t\t}\n+\n+\t\t\t// Swap back\n+\t\t\tdigits[idx], digits[i] = digits[i], digits[idx]\n+\t\t}\n+\n+\t\treturn false\n+\t}\n+\n+\tif solveRecursive(0) {\n+\t\t// Build the return map converting rune keys to string keys\n+\t\tresult := make(map[string]int)\n+\t\tfor k, v := range assignment {\n+\t\t\tresult[string(k)] = v\n+\t\t}\n+\t\treturn result, nil\n+\t}\n+\n+\treturn nil, errors.New(\"no solution exists\")\n+}\n+\n+// Helper function to convert a word into its numeric value based on a given assignment\n+func wordToNumber(word string, assignment map[rune]int) (int, error) {\n+\tnum := 0\n+\tfor _, ch := range word {\n+\t\tdigit, ok := assignment[ch]\n+\t\tif !ok {\n+\t\t\treturn 0, errors.New(\"letter not assigned\")\n+\t\t}\n+\t\tnum = num*10 + digit\n+\t}\n+\treturn num, nil\n }\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}