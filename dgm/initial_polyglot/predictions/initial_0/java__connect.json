{
    "instance_id": "java__connect",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/src/main/java/Connect.java b/src/main/java/Connect.java\nindex e31c665..96622dc 100644\n--- a/src/main/java/Connect.java\n+++ b/src/main/java/Connect.java\n@@ -1,10 +1,117 @@\n class Connect {\n \n-    public Connect(String[] board) {\n-        throw new UnsupportedOperationException(\"Implement this function\");\n+    private final char[][] board;\n+    private final int rows;\n+    private final int cols;\n+\n+    // Neighbor offsets for a hexagonal grid (using axial coordinates for a parallelogram board)\n+    private final int[][] DIRS = { {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0} };\n+\n+    public enum Winner {\n+        O, X, NONE\n+    }\n+\n+    // The constructor accepts a board representation as an array of strings.\n+    // Each string may contain spaces for formatting which should be ignored.\n+    public Connect(String[] boardLines) {\n+        // Clean up the boardLines by removing spaces\n+        // Assume all lines, after removing spaces, form a rectangular board\n+        int r = boardLines.length;\n+        if (r == 0) {\n+            throw new IllegalArgumentException(\"Board must have at least one row\");\n+        }\n+        // Remove spaces and create board 2d char array\n+        String[] cleaned = new String[r];\n+        for (int i = 0; i < r; i++) {\n+            cleaned[i] = boardLines[i].replace(\" \", \"\");\n+        }\n+        this.rows = r;\n+        this.cols = cleaned[0].length();\n+        board = new char[rows][cols];\n+        for (int i = 0; i < rows; i++) {\n+            if (cleaned[i].length() != cols) {\n+                throw new IllegalArgumentException(\"All rows must have the same number of columns\");\n+            }\n+            board[i] = cleaned[i].toCharArray();\n+        }\n     }\n \n     public Winner computeWinner() {\n-        throw new UnsupportedOperationException(\"Implement this function\");\n+        boolean oWins = hasPath('O'); // O wins if there's a continuous path from top (row 0) to bottom (row rows-1)\n+        boolean xWins = hasPathForX('X'); // X wins if there's a path from left (col 0) to right (col cols-1)\n+\n+        if (oWins && !xWins) {\n+            return Winner.O;\n+        } else if (xWins && !oWins) {\n+            return Winner.X;\n+        } else {\n+            return Winner.NONE;\n+        }\n+    }\n+\n+    // Check connectivity for player O: top-to-bottom\n+    private boolean hasPath(char player) {\n+        boolean[][] visited = new boolean[rows][cols];\n+        // Start DFS from all positions in the top row that contain the player's stone\n+        for (int col = 0; col < cols; col++) {\n+            if (board[0][col] == player) {\n+                if (dfsO(0, col, visited)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean dfsO(int r, int c, boolean[][] visited) {\n+        if (r == rows - 1) {\n+            return true;\n+        }\n+        visited[r][c] = true;\n+        for (int[] d : DIRS) {\n+            int nr = r + d[0];\n+            int nc = c + d[1];\n+            if (isValid(nr, nc) && !visited[nr][nc] && board[nr][nc] == 'O') {\n+                if (dfsO(nr, nc, visited)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    // Check connectivity for player X: left-to-right\n+    private boolean hasPathForX(char player) {\n+        boolean[][] visited = new boolean[rows][cols];\n+        // Start DFS from all positions in the left column that belong to player\n+        for (int row = 0; row < rows; row++) {\n+            if (board[row][0] == player) {\n+                if (dfsX(row, 0, visited)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean dfsX(int r, int c, boolean[][] visited) {\n+        if (c == cols - 1) {\n+            return true;\n+        }\n+        visited[r][c] = true;\n+        for (int[] d : DIRS) {\n+            int nr = r + d[0];\n+            int nc = c + d[1];\n+            if (isValid(nr, nc) && !visited[nr][nc] && board[nr][nc] == 'X') {\n+                if (dfsX(nr, nc, visited)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean isValid(int r, int c) {\n+        return r >= 0 && r < rows && c >= 0 && c < cols;\n     }\n }\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}