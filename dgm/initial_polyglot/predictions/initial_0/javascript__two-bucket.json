{
    "instance_id": "javascript__two-bucket",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/two-bucket.js b/two-bucket.js\nindex 2e4b8f5..3d8d0e7 100644\n--- a/two-bucket.js\n+++ b/two-bucket.js\n@@ -1,14 +1,119 @@\n //\n-// This is only a SKELETON file for the 'Two Bucket' exercise. It's been provided as a\n-// convenience to get you started writing code faster.\n+// Two Bucket exercise solution implementation.\n //\n+// The TwoBucket class is constructed with the following parameters:\n+// bucketOne: capacity of bucket one\n+// bucketTwo: capacity of bucket two\n+// goal: the desired amount of liters to measure\n+// startBucket: a string, either 'one' or 'two', indicating which bucket to fill first\n+//\n+// The solve() method returns an object with properties:\n+// moves - the total number of actions required (including the first fill)\n+// goalBucket - the name of the bucket that ends up with the goal amount ('one' or 'two')\n+// otherBucket - the amount contained in the other bucket\n+//\n+// Only three actions are allowed: fill a bucket, empty a bucket, and pour from one bucket to the other.\n+// Additionally, after any action, you may not end up with a state where the initial starting bucket is empty and the other bucket is full.\n \n export class TwoBucket {\n-  constructor() {\n-    throw new Error('Remove this statement and implement this function');\n+  constructor(bucketOne, bucketTwo, goal, startBucket) {\n+    this.bucketOne = bucketOne;\n+    this.bucketTwo = bucketTwo;\n+    this.goal = goal;\n+    // startBucket must be either 'one' or 'two'\n+    if (startBucket !== 'one' && startBucket !== 'two') {\n+      throw new Error(\"startBucket must be either 'one' or 'two'\");\n+    }\n+    this.startBucket = startBucket;\n   }\n \n   solve() {\n-    throw new Error('Remove this statement and implement this function');\n+    // If the goal is already exactly the capacity of one of the buckets, we might end immediately\n+    if (this.bucketOne === this.goal) {\n+      return {\n+        moves: 1,\n+        goalBucket: 'one',\n+        otherBucket: 0\n+      };\n+    }\n+    if (this.bucketTwo === this.goal) {\n+      return {\n+        moves: 1,\n+        goalBucket: 'two',\n+        otherBucket: 0\n+      };\n+    }\n+\n+    // Determine which bucket is the starting bucket (source) and which is the other (destination)\n+    let fromCap, toCap;\n+    let fromLabel, toLabel;\n+\n+    if (this.startBucket === 'one') {\n+      fromCap = this.bucketOne;\n+      toCap = this.bucketTwo;\n+      fromLabel = 'one';\n+      toLabel = 'two';\n+    } else {\n+      fromCap = this.bucketTwo;\n+      toCap = this.bucketOne;\n+      fromLabel = 'two';\n+      toLabel = 'one';\n+    }\n+\n+    // First action: fill the starting bucket\n+    let fromAmount = fromCap;\n+    let toAmount = 0;\n+    let moves = 1; // initial fill\n+\n+    // We'll simulate the process until one bucket reaches the goal\n+    while (fromAmount !== this.goal && toAmount !== this.goal) {\n+      // Pour from 'from' bucket to 'to' bucket\n+      let amountToPour = Math.min(fromAmount, toCap - toAmount);\n+      fromAmount -= amountToPour;\n+      toAmount += amountToPour;\n+      moves++;\n+\n+      // Check forbidden state: starting bucket (the one originally filled) should not be empty while the other is full\n+      // That is: if our starting bucket (from) is empty and the other bucket (to) is full, that's not allowed.\n+      if (fromAmount === 0 && toAmount === toCap) {\n+        // Instead of performing an action that leads to this state, we avoid it.\n+        // However, by the puzzle description, this state should never be reached if the problem has a solution.\n+        break;\n+      }\n+\n+      // If we've reached the goal, break.\n+      if (fromAmount === this.goal || toAmount === this.goal) {\n+        break;\n+      }\n+\n+      // If the 'from' bucket is empty, refill it.\n+      if (fromAmount === 0) {\n+        fromAmount = fromCap;\n+        moves++;\n+      } else if (toAmount === toCap) {\n+        // If the 'to' bucket is full, empty it.\n+        toAmount = 0;\n+        moves++;\n+      }\n+    }\n+\n+    // Determine which bucket ended up with the goal\n+    if (fromAmount === this.goal) {\n+      // The bucket that was initially filled (from) reached the goal\n+      return {\n+        moves: moves,\n+        goalBucket: fromLabel,\n+        otherBucket: toAmount\n+      };\n+    } else if (toAmount === this.goal) {\n+      return {\n+        moves: moves,\n+        goalBucket: toLabel,\n+        otherBucket: fromAmount\n+      };\n+    }\n+\n+    // If no solution found, throw error (though based on problem constraints, there should always be a solution)\n+    throw new Error('No solution found');\n   }\n }\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}