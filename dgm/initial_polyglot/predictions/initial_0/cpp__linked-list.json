{
    "instance_id": "cpp__linked-list",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/linked_list.h b/linked_list.h\nindex b2fe817..479e6f7 100644\n--- a/linked_list.h\n+++ b/linked_list.h\n@@ -1,5 +1,130 @@\n #pragma once\n \n+#include <stdexcept>\n+#include <cstddef>\n+\n namespace linked_list {\n \n-}  // namespace linked_list\n+template <typename T>\n+class List {\n+public:\n+    List() : head(nullptr), tail(nullptr), size(0) {}\n+    ~List();\n+\n+    // Add an element to the end of the list\n+    void push(const T &value) {\n+        Node* node = new Node(value);\n+        if (!tail) {\n+            head = tail = node;\n+        } else {\n+            tail->next = node;\n+            node->prev = tail;\n+            tail = node;\n+        }\n+        ++size;\n+    }\n+\n+    // Remove and return the last element of the list\n+    T pop() {\n+        if (!tail) {\n+            throw std::runtime_error(\"pop on empty list\");\n+        }\n+        T val = tail->data;\n+        Node* temp = tail;\n+        tail = tail->prev;\n+        if (tail) {\n+            tail->next = nullptr;\n+        } else {\n+            head = nullptr;\n+        }\n+        delete temp;\n+        --size;\n+        return val;\n+    }\n+\n+    // Add an element to the beginning of the list\n+    void unshift(const T &value) {\n+        Node* node = new Node(value);\n+        if (!head) {\n+            head = tail = node;\n+        } else {\n+            head->prev = node;\n+            node->next = head;\n+            head = node;\n+        }\n+        ++size;\n+    }\n+\n+    // Remove and return the first element of the list\n+    T shift() {\n+        if (!head) {\n+            throw std::runtime_error(\"shift on empty list\");\n+        }\n+        T val = head->data;\n+        Node* temp = head;\n+        head = head->next;\n+        if (head) {\n+            head->prev = nullptr;\n+        } else {\n+            tail = nullptr;\n+        }\n+        delete temp;\n+        --size;\n+        return val;\n+    }\n+\n+    // Return the number of elements in the list\n+    std::size_t count() const {\n+        return size;\n+    }\n+\n+    // Erase the first occurrence of value from the list\n+    // Returns true if an element was removed, false otherwise\n+    bool erase(const T &value) {\n+        Node* current = head;\n+        while (current) {\n+            if (current->data == value) {\n+                if (current->prev) {\n+                    current->prev->next = current->next;\n+                } else {\n+                    head = current->next;\n+                }\n+                if (current->next) {\n+                    current->next->prev = current->prev;\n+                } else {\n+                    tail = current->prev;\n+                }\n+                delete current;\n+                --size;\n+                return true;\n+            }\n+            current = current->next;\n+        }\n+        return false;\n+    }\n+\n+private:\n+    struct Node {\n+        T data;\n+        Node* next;\n+        Node* prev;\n+        Node(const T &data) : data(data), next(nullptr), prev(nullptr) {}\n+    };\n+\n+    Node* head;\n+    Node* tail;\n+    std::size_t size;\n+};\n+\n+// Destructor defined outside the class definition\n+// Iteratively delete nodes\n+template <typename T>\n+List<T>::~List() {\n+    while(head) {\n+        Node* temp = head;\n+        head = head->next;\n+        delete temp;\n+    }\n+}\n+\n+} // namespace linked_list\n",
    "proposed_model_patches": [],
    "eval_result": "resolved",
    "success": true
}