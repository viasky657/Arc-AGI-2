{
    "instance_id": "go__poker",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/poker.go b/poker.go\nindex 2d9807d..4d4ffb9 100644\n--- a/poker.go\n+++ b/poker.go\n@@ -1,5 +1,318 @@\n package poker\n \n+import (\n+\t\"errors\"\n+\t\"sort\"\n+\t\"strings\"\n+)\n+\n+// Card representation\n+// Cards are represented as a rank and a suit.\n+// Example: \"10H\", \"AS\", \"3D\", etc.\n+\n+// rankMap maps card string to its integer value (2-14).\n+var rankMap = map[string]int{\n+\t\"2\":  2,\n+\t\"3\":  3,\n+\t\"4\":  4,\n+\t\"5\":  5,\n+\t\"6\":  6,\n+\t\"7\":  7,\n+\t\"8\":  8,\n+\t\"9\":  9,\n+\t\"10\": 10,\n+\t\"J\":  11,\n+\t\"Q\":  12,\n+\t\"K\":  13,\n+\t\"A\":  14,\n+}\n+\n+// Hand evaluation category constants (higher is better).\n+const (\n+\thighCard = iota\n+\tonePair\n+\ttwoPair\n+\tthreeOfAKind\n+\tstraight\n+\tflush\n+\thouse\n+\tfourOfAKind\n+\tstraightFlush\n+)\n+\n+// handValue struct holds evaluated rank and tie-breaker values.\n+type handValue struct {\n+\tcategory int   // The type of hand, higher is better\n+\ttiebreak  []int // Extra tie-breaker values in descending order\n+}\n+\n+// parseHand takes a hand string (e.g., \"10H JH QH KH AH\") and returns the evaluated cards ranks and suits.\n+func parseHand(hand string) ([]int, []string, error) {\n+\tcards := strings.Fields(hand)\n+\tif len(cards) != 5 {\n+\t\treturn nil, nil, errors.New(\"invalid hand: must have exactly 5 cards\")\n+\t}\n+\n+\tranks := make([]int, 0, 5)\n+\tsuits := make([]string, 0, 5)\n+\n+\tfor _, card := range cards {\n+\t\t// Card is number and suit. Suit is last character.\n+\t\tif len(card) < 2 {\n+\t\t\treturn nil, nil, errors.New(\"invalid card: \" + card)\n+\t\t}\n+\t\t// Get suit as last character\n+\t\tsuit := card[len(card)-1:]\n+\t\t// The rank is the remaining substring\n+\t\trankStr := card[:len(card)-1]\n+\t\tvalue, ok := rankMap[rankStr]\n+\t\tif !ok {\n+\t\t\treturn nil, nil, errors.New(\"unknown rank: \" + rankStr)\n+\t\t}\n+\t\tranks = append(ranks, value)\n+\t\tsuits = append(suits, suit)\n+\t}\n+\n+\treturn ranks, suits, nil\n+}\n+\n+// isFlush returns true if all suits are the same\n+func isFlush(suits []string) bool {\n+\tfirst := suits[0]\n+\tfor _, s := range suits[1:] {\n+\t\tif s != first {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+// isStraight returns true if the ranks form a straight and returns the high card of the straight.\n+// It handles the special case of Ace low straight (A, 2, 3, 4, 5).\n+func isStraight(ranks []int) (bool, int) {\n+\tsorted := append([]int(nil), ranks...)\n+\tsort.Ints(sorted)\n+\n+\t// Check for normal straight\n+\tstraight := true\n+\tfor i := 1; i < len(sorted); i++ {\n+\t\tif sorted[i] != sorted[i-1]+1 {\n+\t\t\tstraight = false\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif straight {\n+\t\t// Highest card is the last one\n+\t\treturn true, sorted[4]\n+\t}\n+\n+\t// Check Ace-low straight: A,2,3,4,5. Sorted would be 2,3,4,5,14\n+\tif sorted[0] == 2 && sorted[1] == 3 && sorted[2] == 4 && sorted[3] == 5 && sorted[4] == 14 {\n+\t\treturn true, 5\n+\t}\n+\n+\treturn false, 0\n+}\n+\n+// countRanks counts the frequency of each rank in the hand.\n+func countRanks(ranks []int) map[int]int {\n+\tcounts := make(map[int]int)\n+\tfor _, r := range ranks {\n+\t\tcounts[r]++\n+\t}\n+\treturn counts\n+}\n+\n+// evaluateHand evaluates a hand string and returns a handValue.\n+func evaluateHand(hand string) (handValue, error) {\n+\tranks, suits, err := parseHand(hand)\n+\tif err != nil {\n+\t\treturn handValue{}, err\n+\t}\n+\n+\tflush := isFlush(suits)\n+\tstraight, highStraight := isStraight(ranks)\n+\tcounts := countRanks(ranks)\n+\n+\t// Prepare a slice of pairs (count, rank) for sorting. We'll sort primarily by count then by rank.\n+\ttype pair struct {\n+\t\tcount int\n+\t\trank  int\n+\t}\n+\n+\tpairs := make([]pair, 0, len(counts))\n+\tfor rank, count := range counts {\n+\t\tpairs = append(pairs, pair{count, rank})\n+\t}\n+\n+\tsort.Slice(pairs, func(i, j int) bool {\n+\t\t// sort by count descending, then rank descending\n+\t\tif pairs[i].count == pairs[j].count {\n+\t\t\treturn pairs[i].rank > pairs[j].rank\n+\t\t}\n+\t\treturn pairs[i].count > pairs[j].count\n+\t})\n+\n+\t// Prepare a sorted list of ranks for tiebreakers in case of flush or high card\n+\tsortedRanks := append([]int(nil), ranks...)\n+\tsort.Sort(sort.Reverse(sort.IntSlice(sortedRanks)))\n+\n+\tvar hv handValue\n+\n+\t// Determine hand category using counts and properties\n+\tif straight && flush {\n+\t\thv.category = straightFlush\n+\t\thv.tiebreak = []int{highStraight}\n+\t\treturn hv, nil\n+\t}\n+\n+\t// Four of a Kind: one rank appears 4 times\n+\tif pairs[0].count == 4 {\n+\t\thv.category = fourOfAKind\n+\t\t// primary: quad rank, then kicker (the other card)\n+\t\tvar kicker int\n+\t\tfor _, p := range pairs {\n+\t\t\tif p.count == 1 {\n+\t\t\t\tkicker = p.rank\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\thv.tiebreak = []int{pairs[0].rank, kicker}\n+\t\treturn hv, nil\n+\t}\n+\n+\t// Full House: one rank 3 times, one rank 2 times\n+\tif pairs[0].count == 3 && pairs[1].count == 2 {\n+\t\thv.category = house\n+\t\thv.tiebreak = []int{pairs[0].rank, pairs[1].rank}\n+\t\treturn hv, nil\n+\t}\n+\n+\t// Flush definition\n+\tif flush {\n+\t\thv.category = flush\n+\t\t// tiebreak: sortedRanks\n+\t\thv.tiebreak = sortedRanks\n+\t\treturn hv, nil\n+\t}\n+\n+\t// Straight definition\n+\tif straight {\n+\t\thv.category = straight\n+\t\thv.tiebreak = []int{highStraight}\n+\t\treturn hv, nil\n+\t}\n+\n+\t// Three of a Kind: one rank appears 3 times\n+\tif pairs[0].count == 3 {\n+\t\thv.category = threeOfAKind\n+\t\t// tiebreak: trip rank then remaining high cards\n+\t\ttripRank := pairs[0].rank\n+\t\t// extract kickers - sort descending\n+\t\tkickers := []int{}\n+\t\tfor _, r := range ranks {\n+\t\t\tif r != tripRank {\n+\t\t\t\tkickers = append(kickers, r)\n+\t\t\t}\n+\t\t}\n+\t\tsort.Sort(sort.Reverse(sort.IntSlice(kickers)))\n+\t\thv.tiebreak = append([]int{tripRank}, kickers...)\n+\t\treturn hv, nil\n+\t}\n+\n+\t// Two Pair: two ranks appear twice\n+\tif len(pairs) >= 2 && pairs[0].count == 2 && pairs[1].count == 2 {\n+\t\thv.category = twoPair\n+\t\t// Get the two pair ranks in descending order, then the kicker\n+\t\ttwoPairs := []int{pairs[0].rank, pairs[1].rank}\n+\t\tsort.Sort(sort.Reverse(sort.IntSlice(twoPairs)))\n+\t\tvar kicker int\n+\t\tfor _, p := range pairs {\n+\t\t\tif p.count == 1 {\n+\t\t\t\tkicker = p.rank\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\thv.tiebreak = append(twoPairs, kicker)\n+\t\treturn hv, nil\n+\t}\n+\n+\t// One Pair: one rank appears twice\n+\tif pairs[0].count == 2 {\n+\t\thv.category = onePair\n+\t\tpairRank := pairs[0].rank\n+\t\t// remaining cards sorted descending\n+\t\tkickers := []int{}\n+\t\tfor _, r := range ranks {\n+\t\t\tif r != pairRank {\n+\t\t\t\tkickers = append(kickers, r)\n+\t\t\t}\n+\t\t}\n+\t\tsort.Sort(sort.Reverse(sort.IntSlice(kickers)))\n+\t\thv.tiebreak = append([]int{pairRank}, kickers...)\n+\t\treturn hv, nil\n+\t}\n+\n+\t// Otherwise High Card\n+\thv.category = highCard\n+\thv.tiebreak = sortedRanks\n+\treturn hv, nil\n+}\n+\n+// compareHandValues compares two handValue structs.\n+// Returns 1 if a > b, -1 if a < b, and 0 if equal.\n+func compareHandValues(a, b handValue) int {\n+\tif a.category > b.category {\n+\t\treturn 1\n+\t} else if a.category < b.category {\n+\t\treturn -1\n+\t}\n+\t// Categories are equal, compare tie-breakers element by element\n+\tminLen := len(a.tiebreak)\n+\tif len(b.tiebreak) < minLen {\n+\t\tminLen = len(b.tiebreak)\n+\t}\n+\tfor i := 0; i < minLen; i++ {\n+\t\tif a.tiebreak[i] > b.tiebreak[i] {\n+\t\t\treturn 1\n+\t\t} else if a.tiebreak[i] < b.tiebreak[i] {\n+\t\t\treturn -1\n+\t\t}\n+\t}\n+\treturn 0\n+}\n+\n+// BestHand selects the best poker hand (or hands in case of a tie) from a list of hands.\n func BestHand(hands []string) ([]string, error) {\n-\tpanic(\"Please implement the BestHand function\")\n+\tif len(hands) == 0 {\n+\t\treturn nil, errors.New(\"no hands provided\")\n+\t}\n+\n+\t// Evaluate each hand\n+\tevaluations := make([]handValue, len(hands))\n+\tfor i, hand := range hands {\n+\t\thv, err := evaluateHand(hand)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tevaluations[i] = hv\n+\t}\n+\n+\t// Determine the best hand value\n+\tbestEval := evaluations[0]\n+\tfor i := 1; i < len(evaluations); i++ {\n+\t\tif compareHandValues(evaluations[i], bestEval) > 0 {\n+\t\t\tbestEval = evaluations[i]\n+\t\t}\n+\t}\n+\n+\t// Collect all hands matching the best evaluation\n+\tresult := []string{}\n+\tfor i, hv := range evaluations {\n+\t\tif compareHandValues(hv, bestEval) == 0 {\n+\t\t\tresult = append(result, hands[i])\n+\t\t}\n+\t}\n+\n+\treturn result, nil\n }\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}