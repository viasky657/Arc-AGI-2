{
    "instance_id": "java__palindrome-products",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/src/main/java/PalindromeCalculator.java b/src/main/java/PalindromeCalculator.java\nindex bf8bdb8..9e7776e 100644\n--- a/src/main/java/PalindromeCalculator.java\n+++ b/src/main/java/PalindromeCalculator.java\n@@ -1,10 +1,66 @@\n+import java.util.ArrayList;\n import java.util.List;\n import java.util.SortedMap;\n+import java.util.TreeMap;\n \n class PalindromeCalculator {\n \n+    // Returns a SortedMap where the key is a palindromic product and the value is a list of factor pairs (each pair is a list of two integers).\n+    // Only the smallest and largest palindrome products are returned.\n+    // If no palindrome is found, an IllegalArgumentException is thrown.\n     SortedMap<Long, List<List<Integer>>> getPalindromeProductsWithFactors(int minFactor, int maxFactor) {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n+        if (minFactor > maxFactor) {\n+            throw new IllegalArgumentException(\"minFactor must be <= maxFactor\");\n+        }\n+\n+        // Temporary map to hold all palindromic products and their factor pairs\n+        SortedMap<Long, List<List<Integer>>> palindromes = new TreeMap<>();\n+\n+        // Iterate over all pairs (i, j) with i <= j to avoid duplicate factor pairs (since multiplication is commutative)\n+        for (int i = minFactor; i <= maxFactor; i++) {\n+            for (int j = i; j <= maxFactor; j++) {\n+                long product = (long) i * j;\n+                if (isPalindrome(product)) {\n+                    // Create a pair list\n+                    List<Integer> pair = new ArrayList<>();\n+                    pair.add(i);\n+                    pair.add(j);\n+                    \n+                    // Add the factor pair to the list associated with this product\n+                    palindromes.computeIfAbsent(product, k -> new ArrayList<>()).add(pair);\n+                }\n+            }\n+        }\n+\n+        if (palindromes.isEmpty()) {\n+            throw new IllegalArgumentException(\"No palindrome found in the given range.\");\n+        }\n+\n+        // Prepare the result: only the smallest and largest palindromic products\n+        SortedMap<Long, List<List<Integer>>> result = new TreeMap<>();\n+        Long smallest = palindromes.firstKey();\n+        Long largest = palindromes.lastKey();\n+        result.put(smallest, palindromes.get(smallest));\n+        if (!largest.equals(smallest)) {\n+            result.put(largest, palindromes.get(largest));\n+        }\n+        \n+        return result;\n+    }\n+\n+    // Helper method to check if a number is a palindrome\n+    private boolean isPalindrome(long number) {\n+        String str = Long.toString(number);\n+        int left = 0;\n+        int right = str.length() - 1;\n+        while (left < right) {\n+            if (str.charAt(left) != str.charAt(right)) {\n+                return false;\n+            }\n+            left++;\n+            right--;\n+        }\n+        return true;\n     }\n \n-}\n\\ No newline at end of file\n+}\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}