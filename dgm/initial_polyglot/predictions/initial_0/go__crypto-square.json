{
    "instance_id": "go__crypto-square",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/crypto_square.go b/crypto_square.go\nindex 5da31f8..344e815 100644\n--- a/crypto_square.go\n+++ b/crypto_square.go\n@@ -1,5 +1,68 @@\n package cryptosquare\n \n+import (\n+\t\"math\"\n+\t\"strings\"\n+\t\"unicode\"\n+)\n+\n+// Encode takes a plaintext string and encodes it using the crypto square method.\n+// It normalizes the text (removes spaces and punctuation, downcases letters), then arranges\n+// the text into a rectangle that is as close to square as possible. The encoded message is\n+// obtained by reading down the columns, with proper spacing and padding for incomplete rows.\n func Encode(pt string) string {\n-\tpanic(\"Please implement the Encode function\")\n+\t// Normalize: remove spaces and punctuation, and convert to lowercase.\n+\tvar normalizedBuilder strings.Builder\n+\tfor _, r := range pt {\n+\t\tif unicode.IsLetter(r) || unicode.IsDigit(r) {\n+\t\t\tnormalizedBuilder.WriteRune(unicode.ToLower(r))\n+\t\t}\n+\t}\n+\tnormalized := normalizedBuilder.String()\n+\tL := len(normalized)\n+\tif L == 0 {\n+\t\treturn \"\"\n+\t}\n+\n+\t// Determine the number of rows (r) and columns (c)\n+\t// The rectangle will have r x c dimensions such that:\n+\t// - r * c >= L,\n+\t// - c >= r,\n+\t// - and c - r <= 1.\n+\t// A typical approach is to let r = floor(sqrt(L)) and c = ceil(sqrt(L)).\n+\t// If r * c is still less than L, increase r by 1.\n+\n+\tsqrtL := math.Sqrt(float64(L))\n+\tr := int(math.Floor(sqrtL))\n+\tc := int(math.Ceil(sqrtL))\n+\tif r*c < L {\n+\t\tr++\n+\t}\n+\n+\t// Create the rectangle by splitting normalized text into rows of length c, padding with spaces if necessary\n+\trows := make([]string, r)\n+\tfor i := 0; i < r; i++ {\n+\t\tstart := i * c\n+\t\tend := start + c\n+\t\tif end > L {\n+\t\t\trow := normalized[start:L]\n+\t\t\trow += strings.Repeat(\" \", c-len(row))\n+\t\t\trows[i] = row\n+\t\t} else {\n+\t\t\trows[i] = normalized[start:end]\n+\t\t}\n+\t}\n+\n+\t// Read down the columns to form chunks\n+\tchunks := make([]string, c)\n+\tfor j := 0; j < c; j++ {\n+\t\tvar chunkBuilder strings.Builder\n+\t\tfor i := 0; i < r; i++ {\n+\t\t\tchunkBuilder.WriteByte(rows[i][j])\n+\t\t}\n+\t\tchunks[j] = chunkBuilder.String()\n+\t}\n+\n+\t// Join the chunks with a space\n+\treturn strings.Join(chunks, \" \")\n }\n",
    "proposed_model_patches": [],
    "eval_result": "resolved",
    "success": true
}