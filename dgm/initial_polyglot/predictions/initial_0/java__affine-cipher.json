{
    "instance_id": "java__affine-cipher",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/src/main/java/AffineCipher.java b/src/main/java/AffineCipher.java\nindex ed2f14c..63897c2 100644\n--- a/src/main/java/AffineCipher.java\n+++ b/src/main/java/AffineCipher.java\n@@ -1,10 +1,99 @@\n public class AffineCipher {\n+    private static final int ALPHABET_SIZE = 26;\n+    \n+    // Helper method to compute gcd\n+    private int gcd(int a, int b) {\n+        if (b == 0) return Math.abs(a);\n+        return gcd(b, a % b);\n+    }\n+    \n+    // Helper method to compute a proper modulo as described (result always non-negative)\n+    private int mod(int x, int m) {\n+        int r = x % m;\n+        return (r < 0) ? r + m : r;\n+    }\n+    \n+    // Helper method to find modular multiplicative inverse of a mod m\n+    // Assumes that a and m are coprime\n+    private int modInverse(int a, int m) {\n+        a = mod(a, m);\n+        for (int x = 1; x < m; x++) {\n+            if (mod(a * x, m) == 1) {\n+                return x;\n+            }\n+        }\n+        // Should not happen if a and m are coprime\n+        throw new IllegalArgumentException(\"No modular inverse exists for a = \" + a + \" and m = \" + m);\n+    }\n+    \n+    // Method to sanitize input: remove spaces and punctuation, keep letters and digits\n+    private String sanitize(String text) {\n+        StringBuilder sb = new StringBuilder();\n+        for (char c : text.toCharArray()) {\n+            if (Character.isLetter(c) || Character.isDigit(c)) {\n+                // Convert letters to lowercase\n+                sb.append(Character.isLetter(c) ? Character.toLowerCase(c) : c);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+    \n+    // Groups text into chunks of 5 separated by a space\n+    private String groupText(String text) {\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < text.length(); i++) {\n+            if (i > 0 && i % 5 == 0) {\n+                sb.append(' ');\n+            }\n+            sb.append(text.charAt(i));\n+        }\n+        return sb.toString();\n+    }\n     \n     public String encode(String text, int coefficient1, int coefficient2){\n-        throw new UnsupportedOperationException(\"Please implement AffineCipher.encode() method.\");\n+        // Check that coefficient1 (a) and ALPHABET_SIZE (m) are coprime\n+        if (gcd(coefficient1, ALPHABET_SIZE) != 1) {\n+            throw new IllegalArgumentException(\"Error: coefficient1 and \" + ALPHABET_SIZE + \" are not coprime.\");\n+        }\n+        \n+        String sanitized = sanitize(text);\n+        StringBuilder encoded = new StringBuilder();\n+        \n+        for (char c : sanitized.toCharArray()) {\n+            if (Character.isLetter(c)) {\n+                int index = c - 'a';\n+                int encryptedIndex = mod(coefficient1 * index + coefficient2, ALPHABET_SIZE);\n+                char encryptedChar = (char) ('a' + encryptedIndex);\n+                encoded.append(encryptedChar);\n+            } else { // digit remains unchanged\n+                encoded.append(c);\n+            }\n+        }\n+        \n+        return groupText(encoded.toString());\n     }\n-\n+    \n     public String decode(String text, int coefficient1, int coefficient2){\n-        throw new UnsupportedOperationException(\"Please implement AffineCipher.decode() method.\");\n+        // Check that coefficient1 (a) and ALPHABET_SIZE (m) are coprime\n+        if (gcd(coefficient1, ALPHABET_SIZE) != 1) {\n+            throw new IllegalArgumentException(\"Error: coefficient1 and \" + ALPHABET_SIZE + \" are not coprime.\");\n+        }\n+        \n+        int a_inv = modInverse(coefficient1, ALPHABET_SIZE);\n+        String sanitized = sanitize(text);\n+        StringBuilder decoded = new StringBuilder();\n+        \n+        for (char c : sanitized.toCharArray()) {\n+            if (Character.isLetter(c)) {\n+                int index = c - 'a';\n+                int decryptedIndex = mod(a_inv * (index - coefficient2), ALPHABET_SIZE);\n+                char decryptedChar = (char) ('a' + decryptedIndex);\n+                decoded.append(decryptedChar);\n+            } else { // digit remains unchanged\n+                decoded.append(c);\n+            }\n+        }\n+        \n+        return decoded.toString();\n     }\n-}\n\\ No newline at end of file\n+}\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}