{
    "instance_id": "rust__two-bucket",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/src/lib.rs b/src/lib.rs\nindex ae20764..3201f73 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1,4 +1,6 @@\n-#[derive(PartialEq, Eq, Debug)]\n+use std::collections::{HashSet, VecDeque};\n+\n+#[derive(PartialEq, Eq, Debug, Clone, Copy, Hash)]\n pub enum Bucket {\n     One,\n     Two,\n@@ -16,6 +18,14 @@ pub struct BucketStats {\n     pub other_bucket: u8,\n }\n \n+// We'll define a structure for the state in the BFS:\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+struct State {\n+    a: u8, // amount in bucket one\n+    b: u8, // amount in bucket two\n+    moves: u8, // number of moves so far\n+}\n+\n /// Solve the bucket problem\n pub fn solve(\n     capacity_1: u8,\n@@ -23,7 +33,91 @@ pub fn solve(\n     goal: u8,\n     start_bucket: &Bucket,\n ) -> Option<BucketStats> {\n-    todo!(\n-        \"Given one bucket of capacity {capacity_1}, another of capacity {capacity_2}, starting with {start_bucket:?}, find pours to reach {goal}, or None if impossible\"\n-    );\n+    // Validate input: if goal is larger than both capacities, it's impossible\n+    if goal > capacity_1 && goal > capacity_2 {\n+        return None;\n+    }\n+\n+    // Helper closure to check forbidden state based on starting bucket.\n+    let is_forbidden = |a: u8, b: u8| {\n+        match start_bucket {\n+            Bucket::One => a == 0 && b == capacity_2,\n+            Bucket::Two => b == 0 && a == capacity_1,\n+        }\n+    };\n+\n+    // initial state: fill the starting bucket\n+    let init_state = match start_bucket {\n+        Bucket::One => State { a: capacity_1, b: 0, moves: 1 },\n+        Bucket::Two => State { a: 0, b: capacity_2, moves: 1 },\n+    };\n+\n+    // if the initial state already meets the goal:\n+    if init_state.a == goal {\n+        return Some(BucketStats { moves: init_state.moves, goal_bucket: Bucket::One, other_bucket: init_state.b });\n+    } else if init_state.b == goal {\n+        return Some(BucketStats { moves: init_state.moves, goal_bucket: Bucket::Two, other_bucket: init_state.a });\n+    }\n+\n+    let mut queue = VecDeque::new();\n+    let mut visited = HashSet::new();\n+    queue.push_back(init_state);\n+    visited.insert((init_state.a, init_state.b));\n+\n+    while let Some(state) = queue.pop_front() {\n+        let State { a, b, moves } = state;\n+        // Generate next states with one action each. We'll accumulate possible transitions:\n+        let mut next_states = Vec::new();\n+\n+        // 1. Fill actions\n+        // Fill bucket one, if not full\n+        if a < capacity_1 {\n+            next_states.push(State { a: capacity_1, b, moves: moves + 1 });\n+        }\n+        // Fill bucket two, if not full\n+        if b < capacity_2 {\n+            next_states.push(State { a, b: capacity_2, moves: moves + 1 });\n+        }\n+\n+        // 2. Empty actions\n+        // Empty bucket one if not empty\n+        if a > 0 {\n+            next_states.push(State { a: 0, b, moves: moves + 1 });\n+        }\n+        // Empty bucket two if not empty\n+        if b > 0 {\n+            next_states.push(State { a, b: 0, moves: moves + 1 });\n+        }\n+\n+        // 3. Pour actions\n+        // Pour from bucket one to bucket two, if possible\n+        if a > 0 && b < capacity_2 {\n+            let transfer = u8::min(a, capacity_2 - b);\n+            next_states.push(State { a: a - transfer, b: b + transfer, moves: moves + 1 });\n+        }\n+        // Pour from bucket two to bucket one, if possible\n+        if b > 0 && a < capacity_1 {\n+            let transfer = u8::min(b, capacity_1 - a);\n+            next_states.push(State { a: a + transfer, b: b - transfer, moves: moves + 1 });\n+        }\n+\n+        for next in next_states {\n+            // Check forbidden state rule\n+            if is_forbidden(next.a, next.b) {\n+                continue;\n+            }\n+            if !visited.contains(&(next.a, next.b)) {\n+                // Check if this state meets the goal:\n+                if next.a == goal {\n+                    return Some(BucketStats { moves: next.moves, goal_bucket: Bucket::One, other_bucket: next.b });\n+                } else if next.b == goal {\n+                    return Some(BucketStats { moves: next.moves, goal_bucket: Bucket::Two, other_bucket: next.a });\n+                }\n+                visited.insert((next.a, next.b));\n+                queue.push_back(next);\n+            }\n+        }\n+    }\n+\n+    None\n }\n",
    "proposed_model_patches": [],
    "eval_result": "resolved",
    "success": true
}