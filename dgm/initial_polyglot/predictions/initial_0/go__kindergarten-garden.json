{
    "instance_id": "go__kindergarten-garden",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/kindergarten_garden.go b/kindergarten_garden.go\nindex 0db500b..460db72 100644\n--- a/kindergarten_garden.go\n+++ b/kindergarten_garden.go\n@@ -1,19 +1,92 @@\n package kindergarten\n \n-// Define the Garden type here.\n+import (\n+\t\"errors\"\n+\t\"sort\"\n+\t\"strings\"\n+)\n \n-// The diagram argument starts each row with a '\\n'.  This allows Go's\n-// raw string literals to present diagrams in source code nicely as two\n-// rows flush left, for example,\n-//\n-//     diagram := `\n-//     VVCCGG\n-//     VVCCGG`\n+// Garden represents a kindergarten garden with cups of plants assigned to children.\n+// Each child receives 4 cups (2 on each row) from the garden diagram.\n+// The garden diagram is provided as a string with 2 rows (newline separated) and each row has 2*n cups,\n+// where n is the number of children. Plants are encoded as follows: 'G' -> Grass, 'C' -> Clover, 'R' -> Radishes, 'V' -> Violets.\n \n+type Garden struct {\n+\tchildren []string\n+\trow1     []rune\n+\trow2     []rune\n+}\n+\n+// Mapping from plant encoding to plant name.\n+var plantsMap = map[rune]string{\n+\t'G': \"Grass\",\n+\t'C': \"Clover\",\n+\t'R': \"Radishes\",\n+\t'V': \"Violets\",\n+}\n+\n+// NewGarden takes in a diagram string and a list of children, and returns a Garden pointer.\n+// If the children slice is nil or empty, defaults to [Alice, Bob, Charlie, David, Eve, Fred, Ginny, Harriet, Ileana, Joseph, Kincaid, Larry].\n+// The children are always sorted alphabetically. The diagram should contain exactly 2 rows, with each row having 2*n cups, where n is the number of children.\n func NewGarden(diagram string, children []string) (*Garden, error) {\n-\tpanic(\"Please implement the NewGarden function\")\n+\tdiagram = strings.TrimSpace(diagram)\n+\trows := strings.Split(diagram, \"\\n\")\n+\tif len(rows) != 2 {\n+\t\treturn nil, errors.New(\"diagram should contain exactly 2 rows\")\n+\t}\n+\n+\t// Default children ordering if not provided\n+\tif children == nil || len(children) == 0 {\n+\t\tchildren = []string{\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\", \"Fred\", \"Ginny\", \"Harriet\", \"Ileana\", \"Joseph\", \"Kincaid\", \"Larry\"}\n+\t}\n+\n+\t// sort children alphabetically\n+\tsort.Strings(children)\n+\n+\texpectedLen := len(children) * 2\n+\tif len(rows[0]) != expectedLen || len(rows[1]) != expectedLen {\n+\t\treturn nil, errors.New(\"invalid diagram width\")\n+\t}\n+\n+\treturn &Garden{\n+\t\tchildren: children,\n+\t\trow1:     []rune(rows[0]),\n+\t\trow2:     []rune(rows[1]),\n+\t}, nil\n }\n \n+// Plants returns the list of plants for a given child in the order they appear in the garden.\n+// The order is determined as: first row left cup, first row right cup, second row left cup, second row right cup.\n+// If the child's name is not in the garden, returns false as second return value.\n func (g *Garden) Plants(child string) ([]string, bool) {\n-\tpanic(\"Please implement the Plants function\")\n+\t// find the index of the child in the sorted list\n+\tindex := -1\n+\tfor i, name := range g.children {\n+\t\tif name == child {\n+\t\t\tindex = i\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif index == -1 {\n+\t\treturn nil, false\n+\t}\n+\n+\tstart := index * 2\n+\tplantLetters := []rune{\n+\t\tg.row1[start],\n+\t\tg.row1[start+1],\n+\t\tg.row2[start],\n+\t\tg.row2[start+1],\n+\t}\n+\n+\tplants := make([]string, len(plantLetters))\n+\tfor i, letter := range plantLetters {\n+\t\tif plant, ok := plantsMap[letter]; ok {\n+\t\t\tplants[i] = plant\n+\t\t} else {\n+\t\t\tplants[i] = \"Unknown\"\n+\t\t}\n+\t}\n+\n+\treturn plants, true\n }\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}