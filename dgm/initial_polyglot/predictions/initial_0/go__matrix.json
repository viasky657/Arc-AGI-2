{
    "instance_id": "go__matrix",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/matrix.go b/matrix.go\nindex 1d957d5..436c2c8 100644\n--- a/matrix.go\n+++ b/matrix.go\n@@ -1,20 +1,93 @@\n package matrix\n \n-// Define the Matrix type here.\n+import (\n+\t\"errors\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n \n-func New(s string) (Matrix, error) {\n-\tpanic(\"Please implement the New function\")\n+// Matrix represents a matrix of integers.\n+// Internally we store the matrix data in a two-dimensional slice.\n+\n+type Matrix struct {\n+\tdata [][]int\n }\n \n-// Cols and Rows must return the results without affecting the matrix.\n-func (m Matrix) Cols() [][]int {\n-\tpanic(\"Please implement the Cols function\")\n+// New creates a new Matrix from a string representation.\n+// The input string should have rows separated by newlines and numbers separated by whitespace.\n+// It returns an error if the matrix is invalid (e.g., rows with different number of columns or non-integer values).\n+func New(s string) (Matrix, error) {\n+\ts = strings.TrimSpace(s)\n+\tif s == \"\" {\n+\t\treturn Matrix{data: [][]int{}}, nil\n+\t}\n+\trowsStr := strings.Split(s, \"\\n\")\n+\tvar data [][]int\n+\tvar numCols int\n+\n+\tfor i, rowStr := range rowsStr {\n+\t\trowStr = strings.TrimSpace(rowStr)\n+\t\tif rowStr == \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tfields := strings.Fields(rowStr)\n+\t\tif i == 0 {\n+\t\t\tnumCols = len(fields)\n+\t\t} else if len(fields) != numCols {\n+\t\t\treturn Matrix{}, errors.New(\"inconsistent number of columns\")\n+\t\t}\n+\t\t\n+\t\trow := make([]int, len(fields))\n+\t\tfor j, field := range fields {\n+\t\t\tval, err := strconv.Atoi(field)\n+\t\t\tif err != nil {\n+\t\t\t\treturn Matrix{}, err\n+\t\t\t}\n+\t\t\trow[j] = val\n+\t\t}\n+\t\tdata = append(data, row)\n+\t}\n+\n+\treturn Matrix{data: data}, nil\n }\n \n+// Rows returns a copy of the rows of the matrix. Modifying the returned slice does not affect the matrix.\n func (m Matrix) Rows() [][]int {\n-\tpanic(\"Please implement the Rows function\")\n+\trows := make([][]int, len(m.data))\n+\tfor i, row := range m.data {\n+\t\trowCopy := make([]int, len(row))\n+\t\tcopy(rowCopy, row)\n+\t\trows[i] = rowCopy\n+\t}\n+\treturn rows\n+}\n+\n+// Cols returns a copy of the columns of the matrix. Modifying the returned slice does not affect the matrix.\n+func (m Matrix) Cols() [][]int {\n+\tif len(m.data) == 0 {\n+\t\treturn [][]int{}\n+\t}\n+\tnumCols := len(m.data[0])\n+\tcols := make([][]int, numCols)\n+\tfor j := 0; j < numCols; j++ {\n+\t\tcol := make([]int, len(m.data))\n+\t\tfor i := 0; i < len(m.data); i++ {\n+\t\t\tcol[i] = m.data[i][j]\n+\t\t}\n+\t\tcols[j] = col\n+\t}\n+\treturn cols\n }\n \n+// Set alters the matrix by setting the value at the given row and column to val.\n+// The matrix is zero-based (i.e., first row is row 0). If the index is out of bounds the matrix remains unchanged and the function returns false, otherwise it returns true.\n func (m Matrix) Set(row, col, val int) bool {\n-\tpanic(\"Please implement the Set function\")\n+\tif row < 0 || row >= len(m.data) {\n+\t\treturn false\n+\t}\n+\tif len(m.data) == 0 || col < 0 || col >= len(m.data[0]) {\n+\t\treturn false\n+\t}\n+\tm.data[row][col] = val\n+\treturn true\n }\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}