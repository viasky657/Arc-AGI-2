{
    "instance_id": "java__tree-building",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/src/main/java/BuildTree.java b/src/main/java/BuildTree.java\nindex 3a7fdc8..5241456 100644\n--- a/src/main/java/BuildTree.java\n+++ b/src/main/java/BuildTree.java\n@@ -4,69 +4,47 @@ import java.util.Comparator;\n class BuildTree {\n \n     TreeNode buildTree(ArrayList<Record> records) throws InvalidRecordsException {\n+        // If no records, return null (or throw exception based on spec, but here we return null)\n+        if (records.isEmpty()) {\n+            return null;\n+        }\n+\n+        // Sort records by record ID to ensure they are in order\n         records.sort(Comparator.comparing(Record::getRecordId));\n-        ArrayList<Integer> orderedRecordIds = new ArrayList<>();\n \n-        for (Record record : records) {\n-            orderedRecordIds.add(record.getRecordId());\n+        // Validate records are contiguous and have valid parent pointers\n+        // The root record must have recordId 0 and parentId 0\n+        Record rootRecord = records.get(0);\n+        if (rootRecord.getRecordId() != 0 || rootRecord.getParentId() != 0) {\n+            throw new InvalidRecordsException(\"Invalid Records\");\n         }\n \n-        if (records.size() > 0) {\n-            if (orderedRecordIds.get(orderedRecordIds.size() - 1) != orderedRecordIds.size() - 1) {\n+        int n = records.size();\n+        for (int i = 0; i < n; i++) {\n+            Record rec = records.get(i);\n+            // record IDs must be contiguous\n+            if (rec.getRecordId() != i) {\n                 throw new InvalidRecordsException(\"Invalid Records\");\n             }\n-            if (orderedRecordIds.get(0) != 0) {\n+            // For non-root records, parent's id must be less than record id\n+            if (i > 0 && rec.getParentId() >= rec.getRecordId()) {\n                 throw new InvalidRecordsException(\"Invalid Records\");\n             }\n         }\n \n-        ArrayList<TreeNode> treeNodes = new ArrayList<>();\n-\n-        for (int i = 0; i < orderedRecordIds.size(); i++) {\n-            for (Record record : records) {\n-                if (orderedRecordIds.get(i) == record.getRecordId()) {\n-                    if (record.getRecordId() == 0 && record.getParentId() != 0) {\n-                        throw new InvalidRecordsException(\"Invalid Records\");\n-                    }\n-                    if (record.getRecordId() < record.getParentId()) {\n-                        throw new InvalidRecordsException(\"Invalid Records\");\n-                    }\n-                    if (record.getRecordId() == record.getParentId() && record.getRecordId() != 0) {\n-                        throw new InvalidRecordsException(\"Invalid Records\");\n-                    }\n-                    treeNodes.add(new TreeNode(record.getRecordId()));\n-                }\n-            }\n-        }\n-\n-        for (int i = 0; i < orderedRecordIds.size(); i++) {\n-            TreeNode parent;\n-            for (TreeNode n: treeNodes) {\n-                if (i == n.getNodeId()) {\n-                    parent = n;\n-                    for (Record record : records) {\n-                        if (record.getParentId() == i) {\n-                            for (TreeNode node : treeNodes) {\n-                                if (node.getNodeId() == 0) {\n-                                    continue;\n-                                }\n-                                if (record.getRecordId() == node.getNodeId()) {\n-                                    parent.getChildren().add(node);\n-                                }\n-                            }\n-                        }\n-                    }\n-                    break;\n-                }\n-            }\n-\n+        // Create an array of TreeNodes to hold nodes at the index of their recordId\n+        TreeNode[] nodes = new TreeNode[n];\n+        for (int i = 0; i < n; i++) {\n+            nodes[i] = new TreeNode(i);\n         }\n \n-        if (treeNodes.size() > 0) {\n-            return treeNodes.get(0);\n+        // Build tree by assigning each node (except the root) to its parent's children list\n+        for (int i = 1; i < n; i++) {\n+            int parentId = records.get(i).getParentId();\n+            nodes[parentId].getChildren().add(nodes[i]);\n         }\n \n-        return null;\n+        return nodes[0];\n     }\n \n }\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}