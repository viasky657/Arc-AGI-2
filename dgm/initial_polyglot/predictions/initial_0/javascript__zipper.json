{
    "instance_id": "javascript__zipper",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/zipper.js b/zipper.js\nindex bbd19d1..e3d13ea 100644\n--- a/zipper.js\n+++ b/zipper.js\n@@ -1,46 +1,125 @@\n //\n-// This is only a SKELETON file for the 'Zipper' exercise. It's been provided as a\n-// convenience to get you started writing code faster.\n+// This is a solution for the 'Zipper' exercise. The zipper is implemented for a binary tree.\n+// The binary tree is represented as an object with properties: value, left, and right.\n+// The zipper itself holds a focus (current subtree) and a context stack (breadcrumbs) to navigate upward.\n+// Each breadcrumb is an object of the form:\n+// {\n+//   dir: 'left' or 'right', // which child the focus was\n+//   value: parent's value,\n+//   other: the sibling subtree of the focus (the subtree not taken by the focus)\n+// }\n //\n+// Operations provided by the zipper include navigating left, right, up, and modifying node values and children.\n \n export class Zipper {\n-  constructor() {\n-    throw new Error('Remove this statement and implement this function');\n+  // The constructor is not meant to be used directly. Use fromTree(tree) to create a zipper.\n+  constructor(focus, context) {\n+    this.focus = focus;\n+    this.context = context; // stack of breadcrumbs\n   }\n \n-  static fromTree() {\n-    throw new Error('Remove this statement and implement this function');\n+  // fromTree creates a zipper focused on the root of the tree.\n+  static fromTree(tree) {\n+    return new Zipper(tree, []);\n   }\n \n+  // toTree reconstructs the complete tree from the current zipper, incorporating changes.\n   toTree() {\n-    throw new Error('Remove this statement and implement this function');\n+    let node = this.focus;\n+    let ctx = this.context;\n+    // Rebuild the tree by unwinding the context stack\n+    for (let i = ctx.length - 1; i >= 0; i--) {\n+      const crumb = ctx[i];\n+      if (crumb.dir === 'left') {\n+        node = {\n+          value: crumb.value,\n+          left: node,\n+          right: crumb.other\n+        };\n+      } else if (crumb.dir === 'right') {\n+        node = {\n+          value: crumb.value,\n+          left: crumb.other,\n+          right: node\n+        };\n+      }\n+    }\n+    return node;\n   }\n \n+  // Returns the value of the current focus node.\n   value() {\n-    throw new Error('Remove this statement and implement this function');\n+    return this.focus.value;\n   }\n \n+  // Moves the focus to the left child. If no left child exists, returns null.\n   left() {\n-    throw new Error('Remove this statement and implement this function');\n+    if (this.focus.left == null) return null;\n+    // Push a breadcrumb indicating we went left, saving current value and the right child as sibling\n+    const newContext = this.context.concat([{ dir: 'left', value: this.focus.value, other: this.focus.right }]);\n+    return new Zipper(this.focus.left, newContext);\n   }\n \n+  // Moves the focus to the right child. If no right child exists, returns null.\n   right() {\n-    throw new Error('Remove this statement and implement this function');\n+    if (this.focus.right == null) return null;\n+    // Push a breadcrumb indicating we went right, saving current value and the left child as sibling\n+    const newContext = this.context.concat([{ dir: 'right', value: this.focus.value, other: this.focus.left }]);\n+    return new Zipper(this.focus.right, newContext);\n   }\n \n+  // Moves the focus up to the parent node. If already at the root (no parent), returns null.\n   up() {\n-    throw new Error('Remove this statement and implement this function');\n+    if (this.context.length === 0) return null;\n+    const lastIndex = this.context.length - 1;\n+    const lastCrumb = this.context[lastIndex];\n+    const newContext = this.context.slice(0, lastIndex);\n+    let parent;\n+    if (lastCrumb.dir === 'left') {\n+      parent = {\n+        value: lastCrumb.value,\n+        left: this.focus,\n+        right: lastCrumb.other\n+      };\n+    } else if (lastCrumb.dir === 'right') {\n+      parent = {\n+        value: lastCrumb.value,\n+        left: lastCrumb.other,\n+        right: this.focus\n+      };\n+    }\n+    return new Zipper(parent, newContext);\n   }\n \n-  setValue() {\n-    throw new Error('Remove this statement and implement this function');\n+  // Returns a new zipper with the value at the focus replaced with newValue.\n+  setValue(newValue) {\n+    const newFocus = {\n+      value: newValue,\n+      left: this.focus.left,\n+      right: this.focus.right\n+    };\n+    return new Zipper(newFocus, this.context);\n   }\n \n-  setLeft() {\n-    throw new Error('Remove this statement and implement this function');\n+  // Returns a new zipper with the left child replaced with newLeft.\n+  // newLeft is expected to be a subtree (or null).\n+  setLeft(newLeft) {\n+    const newFocus = {\n+      value: this.focus.value,\n+      left: newLeft,\n+      right: this.focus.right\n+    };\n+    return new Zipper(newFocus, this.context);\n   }\n \n-  setRight() {\n-    throw new Error('Remove this statement and implement this function');\n+  // Returns a new zipper with the right child replaced with newRight.\n+  // newRight is expected to be a subtree (or null).\n+  setRight(newRight) {\n+    const newFocus = {\n+      value: this.focus.value,\n+      left: this.focus.left,\n+      right: newRight\n+    };\n+    return new Zipper(newFocus, this.context);\n   }\n }\n",
    "proposed_model_patches": [],
    "eval_result": "resolved",
    "success": true
}