{
    "instance_id": "java__change",
    "model_name_or_path": "20250510_021328--claude-3-5-sonnet-20241022_0",
    "model_patch": "diff --git a/src/main/java/ChangeCalculator.java b/src/main/java/ChangeCalculator.java\nindex 658ff74..c0a3194 100644\n--- a/src/main/java/ChangeCalculator.java\n+++ b/src/main/java/ChangeCalculator.java\n@@ -1,13 +1,77 @@\n import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Collections;\n \n class ChangeCalculator {\n \n+    private final List<Integer> coins;\n+\n+    // Constructor: stores the given coin denominations after basic validations\n     ChangeCalculator(List<Integer> currencyCoins) {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n+        if (currencyCoins == null || currencyCoins.isEmpty()) {\n+            throw new IllegalArgumentException(\"Coin list cannot be null or empty.\");\n+        }\n+        // Ensure all coins are positive\n+        for (Integer coin : currencyCoins) {\n+            if (coin == null || coin <= 0) {\n+                throw new IllegalArgumentException(\"Coin denominations must be positive non-zero integers.\");\n+            }\n+        }\n+        this.coins = currencyCoins;\n     }\n \n+    // Returns a list of coins representing the fewest number of coins that sum up to grandTotal.\n+    // If the grandTotal is negative, or cannot be computed with given coins, an IllegalArgumentException is thrown.\n     List<Integer> computeMostEfficientChange(int grandTotal) {\n-        throw new UnsupportedOperationException(\"Delete this statement and write your own implementation.\");\n-    }\n+        if (grandTotal < 0) {\n+            throw new IllegalArgumentException(\"Change cannot be negative\");\n+        }\n+        // For zero change, return an empty list\n+        if (grandTotal == 0) return new ArrayList<>();\n+\n+        // Dynamic programming approach\n+        // dp[i] holds the fewest number of coins needed for amount i\n+        // Initialize with a value greater than any possible coin count\n+        int max = grandTotal + 1;\n+        int[] dp = new int[grandTotal + 1];\n+        int[] prev = new int[grandTotal + 1]; // to track which coin was used for amount i\n+\n+        for (int i = 1; i <= grandTotal; i++) {\n+            dp[i] = max;\n+            prev[i] = -1;\n+        }\n+        dp[0] = 0;\n \n+        // Build the DP table\n+        for (int i = 1; i <= grandTotal; i++) {\n+            for (Integer coin : coins) {\n+                if (i - coin >= 0 && dp[i - coin] + 1 < dp[i]) {\n+                    dp[i] = dp[i - coin] + 1;\n+                    prev[i] = coin;\n+                }\n+            }\n+        }\n+\n+        // If no solution is found, the value remains max\n+        if (dp[grandTotal] == max) {\n+            throw new IllegalArgumentException(\"The change cannot be computed with the given coin denominations\");\n+        }\n+\n+        // Reconstruct the list of coins used to form the change\n+        List<Integer> result = new ArrayList<>();\n+        int curr = grandTotal;\n+        while (curr > 0) {\n+            int coin = prev[curr];\n+            if (coin == -1) {\n+                // This condition should not occur since we checked for no solution\n+                throw new IllegalStateException(\"An error occurred while reconstructing the solution\");\n+            }\n+            result.add(coin);\n+            curr -= coin;\n+        }\n+\n+        // Optional: sort the result in ascending order to have a consistent order [for example, [5, 10] instead of [10,5]]\n+        Collections.sort(result);\n+        return result;\n+    }\n }\n",
    "proposed_model_patches": [],
    "eval_result": "unresolved",
    "success": true
}