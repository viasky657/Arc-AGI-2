{
    "instance_id": "sphinx-doc__sphinx-8265",
    "model_name_or_path": "nerf_editwholefiles_med_0",
    "model_patch": "diff --git a/doc/conf.py b/doc/conf.py\nindex f62e02a34..7b867b166 100644\n--- a/doc/conf.py\n+++ b/doc/conf.py\n@@ -8,7 +8,8 @@ import sphinx\n extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.todo',\n               'sphinx.ext.autosummary', 'sphinx.ext.extlinks',\n               'sphinx.ext.intersphinx',\n-              'sphinx.ext.viewcode', 'sphinx.ext.inheritance_diagram']\n+              'sphinx.ext.viewcode', 'sphinx.ext.inheritance_diagram',\n+              'sphinx.ext.tuple_fix']  # Add our new extension\n \n master_doc = 'contents'\n templates_path = ['_templates']\n@@ -161,4 +162,4 @@ def setup(app):\n     logger = logging.getLogger(__name__)\n     app.info = lambda *args, **kwargs: logger.info(*args, **kwargs)\n     app.warn = lambda *args, **kwargs: logger.warning(*args, **kwargs)\n-    app.debug = lambda *args, **kwargs: logger.debug(*args, **kwargs)\n+    app.debug = lambda *args, **kwargs: logger.debug(*args, **kwargs)\n\\ No newline at end of file\ndiff --git a/setup.py b/setup.py\nindex a404f1fa5..2c6848797 100644\n--- a/setup.py\n+++ b/setup.py\n@@ -15,22 +15,22 @@ if sys.version_info < (3, 5):\n     sys.exit(1)\n \n install_requires = [\n-    'sphinxcontrib-applehelp',\n-    'sphinxcontrib-devhelp',\n+    'sphinxcontrib-applehelp<=1.0.7',\n+    'sphinxcontrib-devhelp<=1.0.5',\n     'sphinxcontrib-jsmath',\n-    'sphinxcontrib-htmlhelp',\n-    'sphinxcontrib-serializinghtml',\n-    'sphinxcontrib-qthelp',\n-    'Jinja2>=2.3',\n+    'sphinxcontrib-htmlhelp<=2.0.4',\n+    'sphinxcontrib-serializinghtml<=1.1.9',\n+    'sphinxcontrib-qthelp<=1.0.6',\n+    'Jinja2<3.0',\n     'Pygments>=2.0',\n     'docutils>=0.12',\n     'snowballstemmer>=1.1',\n     'babel>=1.3',\n-    'alabaster>=0.7,<0.8',\n+    'alabaster>=0.7,<0.7.12',\n     'imagesize',\n     'requests>=2.5.0',\n     'setuptools',\n-    'packaging',\n+    'packaging', 'markupsafe<=2.0.1',\n ]\n \n extras_require = {\ndiff --git a/sphinx/domains/python.py b/sphinx/domains/python.py\nindex f4bc58b69..935279de2 100644\n--- a/sphinx/domains/python.py\n+++ b/sphinx/domains/python.py\n@@ -123,16 +123,13 @@ def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Nod\n             result.append(addnodes.desc_sig_punctuation('', ']'))\n             return result\n         elif isinstance(node, ast.Tuple):\n+            result = [addnodes.desc_sig_punctuation('', '(')]\n             if node.elts:\n-                result = []\n                 for elem in node.elts:\n                     result.extend(unparse(elem))\n                     result.append(addnodes.desc_sig_punctuation('', ', '))\n                 result.pop()\n-            else:\n-                result = [addnodes.desc_sig_punctuation('', '('),\n-                          addnodes.desc_sig_punctuation('', ')')]\n-\n+            result.append(addnodes.desc_sig_punctuation('', ')'))\n             return result\n         else:\n             if sys.version_info >= (3, 6):\n@@ -140,13 +137,13 @@ def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Nod\n                     if node.value is Ellipsis:\n                         return [addnodes.desc_sig_punctuation('', \"...\")]\n                     else:\n-                        return [nodes.Text(node.value)]\n+                        return [nodes.Text(str(node.value))]\n \n             if sys.version_info < (3, 8):\n                 if isinstance(node, ast.Ellipsis):\n                     return [addnodes.desc_sig_punctuation('', \"...\")]\n                 elif isinstance(node, ast.NameConstant):\n-                    return [nodes.Text(node.value)]\n+                    return [nodes.Text(str(node.value))]\n \n             raise SyntaxError  # unsupported syntax\n \n@@ -165,54 +162,15 @@ def _parse_annotation(annotation: str, env: BuildEnvironment = None) -> List[Nod\n         return [type_to_xref(annotation, env)]\n \n \n-def _parse_arglist(arglist: str, env: BuildEnvironment = None) -> addnodes.desc_parameterlist:\n-    \"\"\"Parse a list of arguments using AST parser\"\"\"\n-    params = addnodes.desc_parameterlist(arglist)\n-    sig = signature_from_str('(%s)' % arglist)\n-    last_kind = None\n-    for param in sig.parameters.values():\n-        if param.kind != param.POSITIONAL_ONLY and last_kind == param.POSITIONAL_ONLY:\n-            # PEP-570: Separator for Positional Only Parameter: /\n-            params += addnodes.desc_parameter('', '', addnodes.desc_sig_operator('', '/'))\n-        if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,\n-                                                              param.POSITIONAL_ONLY,\n-                                                              None):\n-            # PEP-3102: Separator for Keyword Only Parameter: *\n-            params += addnodes.desc_parameter('', '', addnodes.desc_sig_operator('', '*'))\n-\n-        node = addnodes.desc_parameter()\n-        if param.kind == param.VAR_POSITIONAL:\n-            node += addnodes.desc_sig_operator('', '*')\n-            node += addnodes.desc_sig_name('', param.name)\n-        elif param.kind == param.VAR_KEYWORD:\n-            node += addnodes.desc_sig_operator('', '**')\n-            node += addnodes.desc_sig_name('', param.name)\n-        else:\n-            node += addnodes.desc_sig_name('', param.name)\n-\n-        if param.annotation is not param.empty:\n-            children = _parse_annotation(param.annotation, env)\n-            node += addnodes.desc_sig_punctuation('', ':')\n-            node += nodes.Text(' ')\n-            node += addnodes.desc_sig_name('', '', *children)  # type: ignore\n-        if param.default is not param.empty:\n-            if param.annotation is not param.empty:\n-                node += nodes.Text(' ')\n-                node += addnodes.desc_sig_operator('', '=')\n-                node += nodes.Text(' ')\n-            else:\n-                node += addnodes.desc_sig_operator('', '=')\n-            node += nodes.inline('', param.default, classes=['default_value'],\n-                                 support_smartquotes=False)\n-\n-        params += node\n-        last_kind = param.kind\n-\n-    if last_kind == Parameter.POSITIONAL_ONLY:\n-        # PEP-570: Separator for Positional Only Parameter: /\n-        params += addnodes.desc_parameter('', '', addnodes.desc_sig_operator('', '/'))\n-\n-    return params\n+def format_default_value(value: str) -> str:\n+    \"\"\"Format a default value string to preserve tuple formatting.\"\"\"\n+    try:\n+        val = eval(value)\n+        if isinstance(val, tuple):\n+            return str(val)\n+        return value\n+    except Exception:\n+        return value\n \n \n def _pseudo_parse_arglist(signode: desc_signature, arglist: str) -> None:\n@@ -256,1151 +214,58 @@ def _pseudo_parse_arglist(signode: desc_signature, arglist: str) -> None:\n         # if there are too few or too many elements on the stack, just give up\n         # and treat the whole argument list as one argument, discarding the\n         # already partially populated paramlist node\n-        paramlist = addnodes.desc_parameterlist()\n-        paramlist += addnodes.desc_parameter(arglist, arglist)\n-        signode += paramlist\n-    else:\n-        signode += paramlist\n-\n-\n-# This override allows our inline type specifiers to behave like :class: link\n-# when it comes to handling \".\" and \"~\" prefixes.\n-class PyXrefMixin:\n-    def make_xref(self, rolename: str, domain: str, target: str,\n-                  innernode: \"Type[TextlikeNode]\" = nodes.emphasis,\n-                  contnode: Node = None, env: BuildEnvironment = None) -> Node:\n-        result = super().make_xref(rolename, domain, target,  # type: ignore\n-                                   innernode, contnode, env)\n-        result['refspecific'] = True\n-        if target.startswith(('.', '~')):\n-            prefix, result['reftarget'] = target[0], target[1:]\n-            if prefix == '.':\n-                text = target[1:]\n-            elif prefix == '~':\n-                text = target.split('.')[-1]\n-            for node in result.traverse(nodes.Text):\n-                node.parent[node.parent.index(node)] = nodes.Text(text)\n-                break\n-        return result\n-\n-    def make_xrefs(self, rolename: str, domain: str, target: str,\n-                   innernode: \"Type[TextlikeNode]\" = nodes.emphasis,\n-                   contnode: Node = None, env: BuildEnvironment = None) -> List[Node]:\n-        delims = r'(\\s*[\\[\\]\\(\\),](?:\\s*or\\s)?\\s*|\\s+or\\s+)'\n-        delims_re = re.compile(delims)\n-        sub_targets = re.split(delims, target)\n-\n-        split_contnode = bool(contnode and contnode.astext() == target)\n-\n-        results = []\n-        for sub_target in filter(None, sub_targets):\n-            if split_contnode:\n-                contnode = nodes.Text(sub_target)\n-\n-            if delims_re.match(sub_target):\n-                results.append(contnode or innernode(sub_target, sub_target))\n-            else:\n-                results.append(self.make_xref(rolename, domain, sub_target,\n-                                              innernode, contnode, env))\n-\n-        return results\n-\n-\n-class PyField(PyXrefMixin, Field):\n-    def make_xref(self, rolename: str, domain: str, target: str,\n-                  innernode: \"Type[TextlikeNode]\" = nodes.emphasis,\n-                  contnode: Node = None, env: BuildEnvironment = None) -> Node:\n-        if rolename == 'class' and target == 'None':\n-            # None is not a type, so use obj role instead.\n-            rolename = 'obj'\n-\n-        return super().make_xref(rolename, domain, target, innernode, contnode, env)\n-\n-\n-class PyGroupedField(PyXrefMixin, GroupedField):\n-    pass\n-\n-\n-class PyTypedField(PyXrefMixin, TypedField):\n-    def make_xref(self, rolename: str, domain: str, target: str,\n-                  innernode: \"Type[TextlikeNode]\" = nodes.emphasis,\n-                  contnode: Node = None, env: BuildEnvironment = None) -> Node:\n-        if rolename == 'class' and target == 'None':\n-            # None is not a type, so use obj role instead.\n-            rolename = 'obj'\n-\n-        return super().make_xref(rolename, domain, target, innernode, contnode, env)\n-\n-\n-class PyObject(ObjectDescription):\n-    \"\"\"\n-    Description of a general Python object.\n-\n-    :cvar allow_nesting: Class is an object that allows for nested namespaces\n-    :vartype allow_nesting: bool\n-    \"\"\"\n-    option_spec = {\n-        'noindex': directives.flag,\n-        'noindexentry': directives.flag,\n-        'module': directives.unchanged,\n-        'annotation': directives.unchanged,\n-    }\n-\n-    doc_field_types = [\n-        PyTypedField('parameter', label=_('Parameters'),\n-                     names=('param', 'parameter', 'arg', 'argument',\n-                            'keyword', 'kwarg', 'kwparam'),\n-                     typerolename='class', typenames=('paramtype', 'type'),\n-                     can_collapse=True),\n-        PyTypedField('variable', label=_('Variables'), rolename='obj',\n-                     names=('var', 'ivar', 'cvar'),\n-                     typerolename='class', typenames=('vartype',),\n-                     can_collapse=True),\n-        PyGroupedField('exceptions', label=_('Raises'), rolename='exc',\n-                       names=('raises', 'raise', 'exception', 'except'),\n-                       can_collapse=True),\n-        Field('returnvalue', label=_('Returns'), has_arg=False,\n-              names=('returns', 'return')),\n-        PyField('returntype', label=_('Return type'), has_arg=False,\n-                names=('rtype',), bodyrolename='class'),\n-    ]\n-\n-    allow_nesting = False\n-\n-    def get_signature_prefix(self, sig: str) -> str:\n-        \"\"\"May return a prefix to put before the object name in the\n-        signature.\n-        \"\"\"\n-        return ''\n-\n-    def needs_arglist(self) -> bool:\n-        \"\"\"May return true if an empty argument list is to be generated even if\n-        the document contains none.\n-        \"\"\"\n-        return False\n-\n-    def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n-        \"\"\"Transform a Python signature into RST nodes.\n-\n-        Return (fully qualified name of the thing, classname if any).\n-\n-        If inside a class, the current class name is handled intelligently:\n-        * it is stripped from the displayed name if present\n-        * it is added to the full name (return value) if not present\n-        \"\"\"\n-        m = py_sig_re.match(sig)\n-        if m is None:\n-            raise ValueError\n-        prefix, name, arglist, retann = m.groups()\n-\n-        # determine module and class name (if applicable), as well as full name\n-        modname = self.options.get('module', self.env.ref_context.get('py:module'))\n-        classname = self.env.ref_context.get('py:class')\n-        if classname:\n-            add_module = False\n-            if prefix and (prefix == classname or\n-                           prefix.startswith(classname + \".\")):\n-                fullname = prefix + name\n-                # class name is given again in the signature\n-                prefix = prefix[len(classname):].lstrip('.')\n-            elif prefix:\n-                # class name is given in the signature, but different\n-                # (shouldn't happen)\n-                fullname = classname + '.' + prefix + name\n-            else:\n-                # class name is not given in the signature\n-                fullname = classname + '.' + name\n-        else:\n-            add_module = True\n-            if prefix:\n-                classname = prefix.rstrip('.')\n-                fullname = prefix + name\n-            else:\n-                classname = ''\n-                fullname = name\n-\n-        signode['module'] = modname\n-        signode['class'] = classname\n-        signode['fullname'] = fullname\n-\n-        sig_prefix = self.get_signature_prefix(sig)\n-        if sig_prefix:\n-            signode += addnodes.desc_annotation(sig_prefix, sig_prefix)\n-\n-        if prefix:\n-            signode += addnodes.desc_addname(prefix, prefix)\n-        elif add_module and self.env.config.add_module_names:\n-            if modname and modname != 'exceptions':\n-                # exceptions are a special case, since they are documented in the\n-                # 'exceptions' module.\n-                nodetext = modname + '.'\n-                signode += addnodes.desc_addname(nodetext, nodetext)\n-\n-        signode += addnodes.desc_name(name, name)\n-        if arglist:\n-            try:\n-                signode += _parse_arglist(arglist, self.env)\n-            except SyntaxError:\n-                # fallback to parse arglist original parser.\n-                # it supports to represent optional arguments (ex. \"func(foo [, bar])\")\n-                _pseudo_parse_arglist(signode, arglist)\n-            except NotImplementedError as exc:\n-                logger.warning(\"could not parse arglist (%r): %s\", arglist, exc,\n-                               location=signode)\n-                _pseudo_parse_arglist(signode, arglist)\n-        else:\n-            if self.needs_arglist():\n-                # for callables, add an empty parameter list\n-                signode += addnodes.desc_parameterlist()\n-\n-        if retann:\n-            children = _parse_annotation(retann, self.env)\n-            signode += addnodes.desc_returns(retann, '', *children)\n-\n-        anno = self.options.get('annotation')\n-        if anno:\n-            signode += addnodes.desc_annotation(' ' + anno, ' ' + anno)\n-\n-        return fullname, prefix\n-\n-    def get_index_text(self, modname: str, name: Tuple[str, str]) -> str:\n-        \"\"\"Return the text for the index entry of the object.\"\"\"\n-        raise NotImplementedError('must be implemented in subclasses')\n-\n-    def add_target_and_index(self, name_cls: Tuple[str, str], sig: str,\n-                             signode: desc_signature) -> None:\n-        modname = self.options.get('module', self.env.ref_context.get('py:module'))\n-        fullname = (modname + '.' if modname else '') + name_cls[0]\n-        node_id = make_id(self.env, self.state.document, '', fullname)\n-        signode['ids'].append(node_id)\n-\n-        # Assign old styled node_id(fullname) not to break old hyperlinks (if possible)\n-        # Note: Will removed in Sphinx-5.0  (RemovedInSphinx50Warning)\n-        if node_id != fullname and fullname not in self.state.document.ids:\n-            signode['ids'].append(fullname)\n-\n-        self.state.document.note_explicit_target(signode)\n-\n-        domain = cast(PythonDomain, self.env.get_domain('py'))\n-        domain.note_object(fullname, self.objtype, node_id, location=signode)\n-\n-        if 'noindexentry' not in self.options:\n-            indextext = self.get_index_text(modname, name_cls)\n-            if indextext:\n-                self.indexnode['entries'].append(('single', indextext, node_id, '', None))\n-\n-    def before_content(self) -> None:\n-        \"\"\"Handle object nesting before content\n-\n-        :py:class:`PyObject` represents Python language constructs. For\n-        constructs that are nestable, such as a Python classes, this method will\n-        build up a stack of the nesting hierarchy so that it can be later\n-        de-nested correctly, in :py:meth:`after_content`.\n-\n-        For constructs that aren't nestable, the stack is bypassed, and instead\n-        only the most recent object is tracked. This object prefix name will be\n-        removed with :py:meth:`after_content`.\n-        \"\"\"\n-        prefix = None\n-        if self.names:\n-            # fullname and name_prefix come from the `handle_signature` method.\n-            # fullname represents the full object name that is constructed using\n-            # object nesting and explicit prefixes. `name_prefix` is the\n-            # explicit prefix given in a signature\n-            (fullname, name_prefix) = self.names[-1]\n-            if self.allow_nesting:\n-                prefix = fullname\n-            elif name_prefix:\n-                prefix = name_prefix.strip('.')\n-        if prefix:\n-            self.env.ref_context['py:class'] = prefix\n-            if self.allow_nesting:\n-                classes = self.env.ref_context.setdefault('py:classes', [])\n-                classes.append(prefix)\n-        if 'module' in self.options:\n-            modules = self.env.ref_context.setdefault('py:modules', [])\n-            modules.append(self.env.ref_context.get('py:module'))\n-            self.env.ref_context['py:module'] = self.options['module']\n-\n-    def after_content(self) -> None:\n-        \"\"\"Handle object de-nesting after content\n-\n-        If this class is a nestable object, removing the last nested class prefix\n-        ends further nesting in the object.\n-\n-        If this class is not a nestable object, the list of classes should not\n-        be altered as we didn't affect the nesting levels in\n-        :py:meth:`before_content`.\n-        \"\"\"\n-        classes = self.env.ref_context.setdefault('py:classes', [])\n-        if self.allow_nesting:\n-            try:\n-                classes.pop()\n-            except IndexError:\n-                pass\n-        self.env.ref_context['py:class'] = (classes[-1] if len(classes) > 0\n-                                            else None)\n-        if 'module' in self.options:\n-            modules = self.env.ref_context.setdefault('py:modules', [])\n-            if modules:\n-                self.env.ref_context['py:module'] = modules.pop()\n-            else:\n-                self.env.ref_context.pop('py:module')\n-\n-\n-class PyModulelevel(PyObject):\n-    \"\"\"\n-    Description of an object on module level (functions, data).\n-    \"\"\"\n-\n-    def run(self) -> List[Node]:\n-        for cls in self.__class__.__mro__:\n-            if cls.__name__ != 'DirectiveAdapter':\n-                warnings.warn('PyModulelevel is deprecated. '\n-                              'Please check the implementation of %s' % cls,\n-                              RemovedInSphinx40Warning, stacklevel=2)\n-                break\n-        else:\n-            warnings.warn('PyModulelevel is deprecated',\n-                          RemovedInSphinx40Warning, stacklevel=2)\n-\n-        return super().run()\n-\n-    def needs_arglist(self) -> bool:\n-        return self.objtype == 'function'\n-\n-    def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n-        if self.objtype == 'function':\n-            if not modname:\n-                return _('%s() (built-in function)') % name_cls[0]\n-            return _('%s() (in module %s)') % (name_cls[0], modname)\n-        elif self.objtype == 'data':\n-            if not modname:\n-                return _('%s (built-in variable)') % name_cls[0]\n-            return _('%s (in module %s)') % (name_cls[0], modname)\n-        else:\n-            return ''\n-\n-\n-class PyFunction(PyObject):\n-    \"\"\"Description of a function.\"\"\"\n-\n-    option_spec = PyObject.option_spec.copy()\n-    option_spec.update({\n-        'async': directives.flag,\n-    })\n-\n-    def get_signature_prefix(self, sig: str) -> str:\n-        if 'async' in self.options:\n-            return 'async '\n-        else:\n-            return ''\n-\n-    def needs_arglist(self) -> bool:\n-        return True\n-\n-    def add_target_and_index(self, name_cls: Tuple[str, str], sig: str,\n-                             signode: desc_signature) -> None:\n-        super().add_target_and_index(name_cls, sig, signode)\n-        if 'noindexentry' not in self.options:\n-            modname = self.options.get('module', self.env.ref_context.get('py:module'))\n-            node_id = signode['ids'][0]\n-\n-            name, cls = name_cls\n-            if modname:\n-                text = _('%s() (in module %s)') % (name, modname)\n-                self.indexnode['entries'].append(('single', text, node_id, '', None))\n-            else:\n-                text = '%s; %s()' % (pairindextypes['builtin'], name)\n-                self.indexnode['entries'].append(('pair', text, node_id, '', None))\n-\n-    def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n-        # add index in own add_target_and_index() instead.\n-        return None\n-\n-\n-class PyDecoratorFunction(PyFunction):\n-    \"\"\"Description of a decorator.\"\"\"\n-\n-    def run(self) -> List[Node]:\n-        # a decorator function is a function after all\n-        self.name = 'py:function'\n-        return super().run()\n-\n-    def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n-        ret = super().handle_signature(sig, signode)\n-        signode.insert(0, addnodes.desc_addname('@', '@'))\n-        return ret\n-\n-    def needs_arglist(self) -> bool:\n-        return False\n-\n-\n-class PyVariable(PyObject):\n-    \"\"\"Description of a variable.\"\"\"\n-\n-    option_spec = PyObject.option_spec.copy()\n-    option_spec.update({\n-        'type': directives.unchanged,\n-        'value': directives.unchanged,\n-    })\n-\n-    def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n-        fullname, prefix = super().handle_signature(sig, signode)\n-\n-        typ = self.options.get('type')\n-        if typ:\n-            annotations = _parse_annotation(typ, self.env)\n-            signode += addnodes.desc_annotation(typ, '', nodes.Text(': '), *annotations)\n-\n-        value = self.options.get('value')\n-        if value:\n-            signode += addnodes.desc_annotation(value, ' = ' + value)\n-\n-        return fullname, prefix\n-\n-    def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n-        name, cls = name_cls\n-        if modname:\n-            return _('%s (in module %s)') % (name, modname)\n-        else:\n-            return _('%s (built-in variable)') % name\n-\n-\n-class PyClasslike(PyObject):\n-    \"\"\"\n-    Description of a class-like object (classes, interfaces, exceptions).\n-    \"\"\"\n-\n-    option_spec = PyObject.option_spec.copy()\n-    option_spec.update({\n-        'final': directives.flag,\n-    })\n-\n-    allow_nesting = True\n-\n-    def get_signature_prefix(self, sig: str) -> str:\n-        if 'final' in self.options:\n-            return 'final %s ' % self.objtype\n-        else:\n-            return '%s ' % self.objtype\n-\n-    def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n-        if self.objtype == 'class':\n-            if not modname:\n-                return _('%s (built-in class)') % name_cls[0]\n-            return _('%s (class in %s)') % (name_cls[0], modname)\n-        elif self.objtype == 'exception':\n-            return name_cls[0]\n-        else:\n-            return ''\n-\n-\n-class PyClassmember(PyObject):\n-    \"\"\"\n-    Description of a class member (methods, attributes).\n-    \"\"\"\n-\n-    def run(self) -> List[Node]:\n-        for cls in self.__class__.__mro__:\n-            if cls.__name__ != 'DirectiveAdapter':\n-                warnings.warn('PyClassmember is deprecated. '\n-                              'Please check the implementation of %s' % cls,\n-                              RemovedInSphinx40Warning, stacklevel=2)\n-                break\n-        else:\n-            warnings.warn('PyClassmember is deprecated',\n-                          RemovedInSphinx40Warning, stacklevel=2)\n-\n-        return super().run()\n-\n-    def needs_arglist(self) -> bool:\n-        return self.objtype.endswith('method')\n-\n-    def get_signature_prefix(self, sig: str) -> str:\n-        if self.objtype == 'staticmethod':\n-            return 'static '\n-        elif self.objtype == 'classmethod':\n-            return 'classmethod '\n-        return ''\n-\n-    def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n-        name, cls = name_cls\n-        add_modules = self.env.config.add_module_names\n-        if self.objtype == 'method':\n-            try:\n-                clsname, methname = name.rsplit('.', 1)\n-            except ValueError:\n-                if modname:\n-                    return _('%s() (in module %s)') % (name, modname)\n-                else:\n-                    return '%s()' % name\n-            if modname and add_modules:\n-                return _('%s() (%s.%s method)') % (methname, modname, clsname)\n-            else:\n-                return _('%s() (%s method)') % (methname, clsname)\n-        elif self.objtype == 'staticmethod':\n-            try:\n-                clsname, methname = name.rsplit('.', 1)\n-            except ValueError:\n-                if modname:\n-                    return _('%s() (in module %s)') % (name, modname)\n-                else:\n-                    return '%s()' % name\n-            if modname and add_modules:\n-                return _('%s() (%s.%s static method)') % (methname, modname,\n-                                                          clsname)\n-            else:\n-                return _('%s() (%s static method)') % (methname, clsname)\n-        elif self.objtype == 'classmethod':\n-            try:\n-                clsname, methname = name.rsplit('.', 1)\n-            except ValueError:\n-                if modname:\n-                    return _('%s() (in module %s)') % (name, modname)\n-                else:\n-                    return '%s()' % name\n-            if modname:\n-                return _('%s() (%s.%s class method)') % (methname, modname,\n-                                                         clsname)\n-            else:\n-                return _('%s() (%s class method)') % (methname, clsname)\n-        elif self.objtype == 'attribute':\n-            try:\n-                clsname, attrname = name.rsplit('.', 1)\n-            except ValueError:\n-                if modname:\n-                    return _('%s (in module %s)') % (name, modname)\n-                else:\n-                    return name\n-            if modname and add_modules:\n-                return _('%s (%s.%s attribute)') % (attrname, modname, clsname)\n-            else:\n-                return _('%s (%s attribute)') % (attrname, clsname)\n-        else:\n-            return ''\n-\n-\n-class PyMethod(PyObject):\n-    \"\"\"Description of a method.\"\"\"\n-\n-    option_spec = PyObject.option_spec.copy()\n-    option_spec.update({\n-        'abstractmethod': directives.flag,\n-        'async': directives.flag,\n-        'classmethod': directives.flag,\n-        'final': directives.flag,\n-        'property': directives.flag,\n-        'staticmethod': directives.flag,\n-    })\n-\n-    def needs_arglist(self) -> bool:\n-        if 'property' in self.options:\n-            return False\n-        else:\n-            return True\n-\n-    def get_signature_prefix(self, sig: str) -> str:\n-        prefix = []\n-        if 'final' in self.options:\n-            prefix.append('final')\n-        if 'abstractmethod' in self.options:\n-            prefix.append('abstract')\n-        if 'async' in self.options:\n-            prefix.append('async')\n-        if 'classmethod' in self.options:\n-            prefix.append('classmethod')\n-        if 'property' in self.options:\n-            prefix.append('property')\n-        if 'staticmethod' in self.options:\n-            prefix.append('static')\n-\n-        if prefix:\n-            return ' '.join(prefix) + ' '\n-        else:\n-            return ''\n-\n-    def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n-        name, cls = name_cls\n-        try:\n-            clsname, methname = name.rsplit('.', 1)\n-            if modname and self.env.config.add_module_names:\n-                clsname = '.'.join([modname, clsname])\n-        except ValueError:\n-            if modname:\n-                return _('%s() (in module %s)') % (name, modname)\n-            else:\n-                return '%s()' % name\n-\n-        if 'classmethod' in self.options:\n-            return _('%s() (%s class method)') % (methname, clsname)\n-        elif 'property' in self.options:\n-            return _('%s() (%s property)') % (methname, clsname)\n-        elif 'staticmethod' in self.options:\n-            return _('%s() (%s static method)') % (methname, clsname)\n-        else:\n-            return _('%s() (%s method)') % (methname, clsname)\n-\n-\n-class PyClassMethod(PyMethod):\n-    \"\"\"Description of a classmethod.\"\"\"\n-\n-    option_spec = PyObject.option_spec.copy()\n-\n-    def run(self) -> List[Node]:\n-        self.name = 'py:method'\n-        self.options['classmethod'] = True\n-\n-        return super().run()\n-\n-\n-class PyStaticMethod(PyMethod):\n-    \"\"\"Description of a staticmethod.\"\"\"\n-\n-    option_spec = PyObject.option_spec.copy()\n-\n-    def run(self) -> List[Node]:\n-        self.name = 'py:method'\n-        self.options['staticmethod'] = True\n-\n-        return super().run()\n-\n-\n-class PyDecoratorMethod(PyMethod):\n-    \"\"\"Description of a decoratormethod.\"\"\"\n-\n-    def run(self) -> List[Node]:\n-        self.name = 'py:method'\n-        return super().run()\n-\n-    def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n-        ret = super().handle_signature(sig, signode)\n-        signode.insert(0, addnodes.desc_addname('@', '@'))\n-        return ret\n-\n-    def needs_arglist(self) -> bool:\n-        return False\n-\n-\n-class PyAttribute(PyObject):\n-    \"\"\"Description of an attribute.\"\"\"\n-\n-    option_spec = PyObject.option_spec.copy()\n-    option_spec.update({\n-        'type': directives.unchanged,\n-        'value': directives.unchanged,\n-    })\n-\n-    def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n-        fullname, prefix = super().handle_signature(sig, signode)\n-\n-        typ = self.options.get('type')\n-        if typ:\n-            annotations = _parse_annotation(typ, self.env)\n-            signode += addnodes.desc_annotation(typ, '', nodes.Text(': '), *annotations)\n-\n-        value = self.options.get('value')\n-        if value:\n-            signode += addnodes.desc_annotation(value, ' = ' + value)\n-\n-        return fullname, prefix\n-\n-    def get_index_text(self, modname: str, name_cls: Tuple[str, str]) -> str:\n-        name, cls = name_cls\n-        try:\n-            clsname, attrname = name.rsplit('.', 1)\n-            if modname and self.env.config.add_module_names:\n-                clsname = '.'.join([modname, clsname])\n-        except ValueError:\n-            if modname:\n-                return _('%s (in module %s)') % (name, modname)\n-            else:\n-                return name\n-\n-        return _('%s (%s attribute)') % (attrname, clsname)\n-\n-\n-class PyDecoratorMixin:\n-    \"\"\"\n-    Mixin for decorator directives.\n-    \"\"\"\n-    def handle_signature(self, sig: str, signode: desc_signature) -> Tuple[str, str]:\n-        for cls in self.__class__.__mro__:\n-            if cls.__name__ != 'DirectiveAdapter':\n-                warnings.warn('PyDecoratorMixin is deprecated. '\n-                              'Please check the implementation of %s' % cls,\n-                              RemovedInSphinx50Warning, stacklevel=2)\n-                break\n-        else:\n-            warnings.warn('PyDecoratorMixin is deprecated',\n-                          RemovedInSphinx50Warning, stacklevel=2)\n-\n-        ret = super().handle_signature(sig, signode)  # type: ignore\n-        signode.insert(0, addnodes.desc_addname('@', '@'))\n-        return ret\n-\n-    def needs_arglist(self) -> bool:\n-        return False\n-\n-\n-class PyModule(SphinxDirective):\n-    \"\"\"\n-    Directive to mark description of a new module.\n-    \"\"\"\n-\n-    has_content = False\n-    required_arguments = 1\n-    optional_arguments = 0\n-    final_argument_whitespace = False\n-    option_spec = {\n-        'platform': lambda x: x,\n-        'synopsis': lambda x: x,\n-        'noindex': directives.flag,\n-        'deprecated': directives.flag,\n-    }\n-\n-    def run(self) -> List[Node]:\n-        domain = cast(PythonDomain, self.env.get_domain('py'))\n-\n-        modname = self.arguments[0].strip()\n-        noindex = 'noindex' in self.options\n-        self.env.ref_context['py:module'] = modname\n-        ret = []  # type: List[Node]\n-        if not noindex:\n-            # note module to the domain\n-            node_id = make_id(self.env, self.state.document, 'module', modname)\n-            target = nodes.target('', '', ids=[node_id], ismod=True)\n-            self.set_source_info(target)\n-\n-            # Assign old styled node_id not to break old hyperlinks (if possible)\n-            # Note: Will removed in Sphinx-5.0  (RemovedInSphinx50Warning)\n-            old_node_id = self.make_old_id(modname)\n-            if node_id != old_node_id and old_node_id not in self.state.document.ids:\n-                target['ids'].append(old_node_id)\n-\n-            self.state.document.note_explicit_target(target)\n-\n-            domain.note_module(modname,\n-                               node_id,\n-                               self.options.get('synopsis', ''),\n-                               self.options.get('platform', ''),\n-                               'deprecated' in self.options)\n-            domain.note_object(modname, 'module', node_id, location=target)\n-\n-            # the platform and synopsis aren't printed; in fact, they are only\n-            # used in the modindex currently\n-            ret.append(target)\n-            indextext = '%s; %s' % (pairindextypes['module'], modname)\n-            inode = addnodes.index(entries=[('pair', indextext, node_id, '', None)])\n-            ret.append(inode)\n-        return ret\n-\n-    def make_old_id(self, name: str) -> str:\n-        \"\"\"Generate old styled node_id.\n-\n-        Old styled node_id is incompatible with docutils' node_id.\n-        It can contain dots and hyphens.\n-\n-        .. note:: Old styled node_id was mainly used until Sphinx-3.0.\n-        \"\"\"\n-        return 'module-%s' % name\n-\n-\n-class PyCurrentModule(SphinxDirective):\n-    \"\"\"\n-    This directive is just to tell Sphinx that we're documenting\n-    stuff in module foo, but links to module foo won't lead here.\n-    \"\"\"\n-\n-    has_content = False\n-    required_arguments = 1\n-    optional_arguments = 0\n-    final_argument_whitespace = False\n-    option_spec = {}  # type: Dict\n-\n-    def run(self) -> List[Node]:\n-        modname = self.arguments[0].strip()\n-        if modname == 'None':\n-            self.env.ref_context.pop('py:module', None)\n-        else:\n-            self.env.ref_context['py:module'] = modname\n-        return []\n-\n-\n-class PyXRefRole(XRefRole):\n-    def process_link(self, env: BuildEnvironment, refnode: Element,\n-                     has_explicit_title: bool, title: str, target: str) -> Tuple[str, str]:\n-        refnode['py:module'] = env.ref_context.get('py:module')\n-        refnode['py:class'] = env.ref_context.get('py:class')\n-        if not has_explicit_title:\n-            title = title.lstrip('.')    # only has a meaning for the target\n-            target = target.lstrip('~')  # only has a meaning for the title\n-            # if the first character is a tilde, don't display the module/class\n-            # parts of the contents\n-            if title[0:1] == '~':\n-                title = title[1:]\n-                dot = title.rfind('.')\n-                if dot != -1:\n-                    title = title[dot + 1:]\n-        # if the first character is a dot, search more specific namespaces first\n-        # else search builtins first\n-        if target[0:1] == '.':\n-            target = target[1:]\n-            refnode['refspecific'] = True\n-        return title, target\n-\n-\n-def filter_meta_fields(app: Sphinx, domain: str, objtype: str, content: Element) -> None:\n-    \"\"\"Filter ``:meta:`` field from its docstring.\"\"\"\n-    if domain != 'py':\n+        signode += addnodes.desc_parameterlist()\n+        signode[-1] += addnodes.desc_parameter(arglist, arglist)\n         return\n+    signode += paramlist\n \n-    for node in content:\n-        if isinstance(node, nodes.field_list):\n-            fields = cast(List[nodes.field], node)\n-            for field in fields:\n-                field_name = cast(nodes.field_body, field[0]).astext().strip()\n-                if field_name == 'meta' or field_name.startswith('meta '):\n-                    node.remove(field)\n-                    break\n-\n-\n-class PythonModuleIndex(Index):\n-    \"\"\"\n-    Index subclass to provide the Python module index.\n-    \"\"\"\n-\n-    name = 'modindex'\n-    localname = _('Python Module Index')\n-    shortname = _('modules')\n-\n-    def generate(self, docnames: Iterable[str] = None\n-                 ) -> Tuple[List[Tuple[str, List[IndexEntry]]], bool]:\n-        content = {}  # type: Dict[str, List[IndexEntry]]\n-        # list of prefixes to ignore\n-        ignores = None  # type: List[str]\n-        ignores = self.domain.env.config['modindex_common_prefix']  # type: ignore\n-        ignores = sorted(ignores, key=len, reverse=True)\n-        # list of all modules, sorted by module name\n-        modules = sorted(self.domain.data['modules'].items(),\n-                         key=lambda x: x[0].lower())\n-        # sort out collapsable modules\n-        prev_modname = ''\n-        num_toplevels = 0\n-        for modname, (docname, node_id, synopsis, platforms, deprecated) in modules:\n-            if docnames and docname not in docnames:\n-                continue\n \n-            for ignore in ignores:\n-                if modname.startswith(ignore):\n-                    modname = modname[len(ignore):]\n-                    stripped = ignore\n-                    break\n-            else:\n-                stripped = ''\n-\n-            # we stripped the whole module name?\n-            if not modname:\n-                modname, stripped = stripped, ''\n-\n-            entries = content.setdefault(modname[0].lower(), [])\n-\n-            package = modname.split('.')[0]\n-            if package != modname:\n-                # it's a submodule\n-                if prev_modname == package:\n-                    # first submodule - make parent a group head\n-                    if entries:\n-                        last = entries[-1]\n-                        entries[-1] = IndexEntry(last[0], 1, last[2], last[3],\n-                                                 last[4], last[5], last[6])\n-                elif not prev_modname.startswith(package):\n-                    # submodule without parent in list, add dummy entry\n-                    entries.append(IndexEntry(stripped + package, 1, '', '', '', '', ''))\n-                subtype = 2\n-            else:\n-                num_toplevels += 1\n-                subtype = 0\n-\n-            qualifier = _('Deprecated') if deprecated else ''\n-            entries.append(IndexEntry(stripped + modname, subtype, docname,\n-                                      node_id, platforms, qualifier, synopsis))\n-            prev_modname = modname\n-\n-        # apply heuristics when to collapse modindex at page load:\n-        # only collapse if number of toplevel modules is larger than\n-        # number of submodules\n-        collapse = len(modules) - num_toplevels < num_toplevels\n-\n-        # sort by first letter\n-        sorted_content = sorted(content.items())\n-\n-        return sorted_content, collapse\n-\n-\n-class PythonDomain(Domain):\n-    \"\"\"Python language domain.\"\"\"\n-    name = 'py'\n-    label = 'Python'\n-    object_types = {\n-        'function':     ObjType(_('function'),      'func', 'obj'),\n-        'data':         ObjType(_('data'),          'data', 'obj'),\n-        'class':        ObjType(_('class'),         'class', 'exc', 'obj'),\n-        'exception':    ObjType(_('exception'),     'exc', 'class', 'obj'),\n-        'method':       ObjType(_('method'),        'meth', 'obj'),\n-        'classmethod':  ObjType(_('class method'),  'meth', 'obj'),\n-        'staticmethod': ObjType(_('static method'), 'meth', 'obj'),\n-        'attribute':    ObjType(_('attribute'),     'attr', 'obj'),\n-        'module':       ObjType(_('module'),        'mod', 'obj'),\n-    }  # type: Dict[str, ObjType]\n-\n-    directives = {\n-        'function':        PyFunction,\n-        'data':            PyVariable,\n-        'class':           PyClasslike,\n-        'exception':       PyClasslike,\n-        'method':          PyMethod,\n-        'classmethod':     PyClassMethod,\n-        'staticmethod':    PyStaticMethod,\n-        'attribute':       PyAttribute,\n-        'module':          PyModule,\n-        'currentmodule':   PyCurrentModule,\n-        'decorator':       PyDecoratorFunction,\n-        'decoratormethod': PyDecoratorMethod,\n-    }\n-    roles = {\n-        'data':  PyXRefRole(),\n-        'exc':   PyXRefRole(),\n-        'func':  PyXRefRole(fix_parens=True),\n-        'class': PyXRefRole(),\n-        'const': PyXRefRole(),\n-        'attr':  PyXRefRole(),\n-        'meth':  PyXRefRole(fix_parens=True),\n-        'mod':   PyXRefRole(),\n-        'obj':   PyXRefRole(),\n-    }\n-    initial_data = {\n-        'objects': {},  # fullname -> docname, objtype\n-        'modules': {},  # modname -> docname, synopsis, platform, deprecated\n-    }  # type: Dict[str, Dict[str, Tuple[Any]]]\n-    indices = [\n-        PythonModuleIndex,\n-    ]\n-\n-    @property\n-    def objects(self) -> Dict[str, ObjectEntry]:\n-        return self.data.setdefault('objects', {})  # fullname -> ObjectEntry\n-\n-    def note_object(self, name: str, objtype: str, node_id: str, location: Any = None) -> None:\n-        \"\"\"Note a python object for cross reference.\n-\n-        .. versionadded:: 2.1\n-        \"\"\"\n-        if name in self.objects:\n-            other = self.objects[name]\n-            logger.warning(__('duplicate object description of %s, '\n-                              'other instance in %s, use :noindex: for one of them'),\n-                           name, other.docname, location=location)\n-        self.objects[name] = ObjectEntry(self.env.docname, node_id, objtype)\n-\n-    @property\n-    def modules(self) -> Dict[str, ModuleEntry]:\n-        return self.data.setdefault('modules', {})  # modname -> ModuleEntry\n-\n-    def note_module(self, name: str, node_id: str, synopsis: str,\n-                    platform: str, deprecated: bool) -> None:\n-        \"\"\"Note a python module for cross reference.\n-\n-        .. versionadded:: 2.1\n-        \"\"\"\n-        self.modules[name] = ModuleEntry(self.env.docname, node_id,\n-                                         synopsis, platform, deprecated)\n-\n-    def clear_doc(self, docname: str) -> None:\n-        for fullname, obj in list(self.objects.items()):\n-            if obj.docname == docname:\n-                del self.objects[fullname]\n-        for modname, mod in list(self.modules.items()):\n-            if mod.docname == docname:\n-                del self.modules[modname]\n-\n-    def merge_domaindata(self, docnames: List[str], otherdata: Dict) -> None:\n-        # XXX check duplicates?\n-        for fullname, obj in otherdata['objects'].items():\n-            if obj.docname in docnames:\n-                self.objects[fullname] = obj\n-        for modname, mod in otherdata['modules'].items():\n-            if mod.docname in docnames:\n-                self.modules[modname] = mod\n-\n-    def find_obj(self, env: BuildEnvironment, modname: str, classname: str,\n-                 name: str, type: str, searchmode: int = 0\n-                 ) -> List[Tuple[str, ObjectEntry]]:\n-        \"\"\"Find a Python object for \"name\", perhaps using the given module\n-        and/or classname.  Returns a list of (name, object entry) tuples.\n-        \"\"\"\n-        # skip parens\n-        if name[-2:] == '()':\n-            name = name[:-2]\n-\n-        if not name:\n-            return []\n-\n-        matches = []  # type: List[Tuple[str, ObjectEntry]]\n-\n-        newname = None\n-        if searchmode == 1:\n-            if type is None:\n-                objtypes = list(self.object_types)\n-            else:\n-                objtypes = self.objtypes_for_role(type)\n-            if objtypes is not None:\n-                if modname and classname:\n-                    fullname = modname + '.' + classname + '.' + name\n-                    if fullname in self.objects and self.objects[fullname].objtype in objtypes:\n-                        newname = fullname\n-                if not newname:\n-                    if modname and modname + '.' + name in self.objects and \\\n-                       self.objects[modname + '.' + name].objtype in objtypes:\n-                        newname = modname + '.' + name\n-                    elif name in self.objects and self.objects[name].objtype in objtypes:\n-                        newname = name\n-                    else:\n-                        # \"fuzzy\" searching mode\n-                        searchname = '.' + name\n-                        matches = [(oname, self.objects[oname]) for oname in self.objects\n-                                   if oname.endswith(searchname) and\n-                                   self.objects[oname].objtype in objtypes]\n-        else:\n-            # NOTE: searching for exact match, object type is not considered\n-            if name in self.objects:\n-                newname = name\n-            elif type == 'mod':\n-                # only exact matches allowed for modules\n-                return []\n-            elif classname and classname + '.' + name in self.objects:\n-                newname = classname + '.' + name\n-            elif modname and modname + '.' + name in self.objects:\n-                newname = modname + '.' + name\n-            elif modname and classname and \\\n-                    modname + '.' + classname + '.' + name in self.objects:\n-                newname = modname + '.' + classname + '.' + name\n-        if newname is not None:\n-            matches.append((newname, self.objects[newname]))\n-        return matches\n-\n-    def resolve_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,\n-                     type: str, target: str, node: pending_xref, contnode: Element\n-                     ) -> Element:\n-        modname = node.get('py:module')\n-        clsname = node.get('py:class')\n-        searchmode = 1 if node.hasattr('refspecific') else 0\n-        matches = self.find_obj(env, modname, clsname, target,\n-                                type, searchmode)\n-\n-        if not matches and type == 'attr':\n-            # fallback to meth (for property)\n-            matches = self.find_obj(env, modname, clsname, target, 'meth', searchmode)\n-\n-        if not matches:\n-            return None\n-        elif len(matches) > 1:\n-            logger.warning(__('more than one target found for cross-reference %r: %s'),\n-                           target, ', '.join(match[0] for match in matches),\n-                           type='ref', subtype='python', location=node)\n-        name, obj = matches[0]\n+def _parse_arglist(arglist: str, env: BuildEnvironment = None) -> addnodes.desc_parameterlist:\n+    \"\"\"Parse a list of arguments using AST parser.\"\"\"\n+    params = addnodes.desc_parameterlist(arglist)\n+    sig = signature_from_str('(%s)' % arglist)\n+    last_kind = None\n+    for param in sig.parameters.values():\n+        if param.kind != param.POSITIONAL_ONLY and last_kind == param.POSITIONAL_ONLY:\n+            # PEP-570: Separator for Positional Only Parameter: /\n+            params += addnodes.desc_parameter('', '', addnodes.desc_sig_operator('', '/'))\n+        if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,\n+                                                              param.POSITIONAL_ONLY,\n+                                                              None):\n+            # PEP-3102: Separator for Keyword Only Parameter: *\n+            params += addnodes.desc_parameter('', '', addnodes.desc_sig_operator('', '*'))\n \n-        if obj[2] == 'module':\n-            return self._make_module_refnode(builder, fromdocname, name, contnode)\n+        node = addnodes.desc_parameter()\n+        if param.kind == param.VAR_POSITIONAL:\n+            node += addnodes.desc_sig_operator('', '*')\n+            node += addnodes.desc_sig_name('', param.name)\n+        elif param.kind == param.VAR_KEYWORD:\n+            node += addnodes.desc_sig_operator('', '**')\n+            node += addnodes.desc_sig_name('', param.name)\n         else:\n-            return make_refnode(builder, fromdocname, obj[0], obj[1], contnode, name)\n-\n-    def resolve_any_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,\n-                         target: str, node: pending_xref, contnode: Element\n-                         ) -> List[Tuple[str, Element]]:\n-        modname = node.get('py:module')\n-        clsname = node.get('py:class')\n-        results = []  # type: List[Tuple[str, Element]]\n+            node += addnodes.desc_sig_name('', param.name)\n \n-        # always search in \"refspecific\" mode with the :any: role\n-        matches = self.find_obj(env, modname, clsname, target, None, 1)\n-        for name, obj in matches:\n-            if obj[2] == 'module':\n-                results.append(('py:mod',\n-                                self._make_module_refnode(builder, fromdocname,\n-                                                          name, contnode)))\n+        if param.annotation is not param.empty:\n+            children = _parse_annotation(param.annotation, env)\n+            node += addnodes.desc_sig_punctuation('', ':')\n+            node += nodes.Text(' ')\n+            node += addnodes.desc_sig_name('', '', *children)  # type: ignore\n+        if param.default is not param.empty:\n+            default_value = format_default_value(param.default)\n+            if param.annotation is not param.empty:\n+                node += nodes.Text(' ')\n+                node += addnodes.desc_sig_operator('', '=')\n+                node += nodes.Text(' ')\n             else:\n-                results.append(('py:' + self.role_for_objtype(obj[2]),\n-                                make_refnode(builder, fromdocname, obj[0], obj[1],\n-                                             contnode, name)))\n-        return results\n-\n-    def _make_module_refnode(self, builder: Builder, fromdocname: str, name: str,\n-                             contnode: Node) -> Element:\n-        # get additional info for modules\n-        module = self.modules[name]\n-        title = name\n-        if module.synopsis:\n-            title += ': ' + module.synopsis\n-        if module.deprecated:\n-            title += _(' (deprecated)')\n-        if module.platform:\n-            title += ' (' + module.platform + ')'\n-        return make_refnode(builder, fromdocname, module.docname, module.node_id,\n-                            contnode, title)\n-\n-    def get_objects(self) -> Iterator[Tuple[str, str, str, str, str, int]]:\n-        for modname, mod in self.modules.items():\n-            yield (modname, modname, 'module', mod.docname, mod.node_id, 0)\n-        for refname, obj in self.objects.items():\n-            if obj.objtype != 'module':  # modules are already handled\n-                yield (refname, refname, obj.objtype, obj.docname, obj.node_id, 1)\n-\n-    def get_full_qualified_name(self, node: Element) -> str:\n-        modname = node.get('py:module')\n-        clsname = node.get('py:class')\n-        target = node.get('reftarget')\n-        if target is None:\n-            return None\n-        else:\n-            return '.'.join(filter(None, [modname, clsname, target]))\n-\n-\n-def builtin_resolver(app: Sphinx, env: BuildEnvironment,\n-                     node: pending_xref, contnode: Element) -> Element:\n-    \"\"\"Do not emit nitpicky warnings for built-in types.\"\"\"\n-    def istyping(s: str) -> bool:\n-        if s.startswith('typing.'):\n-            s = s.split('.', 1)[1]\n-\n-        return s in typing.__all__  # type: ignore\n-\n-    if node.get('refdomain') != 'py':\n-        return None\n-    elif node.get('reftype') in ('class', 'obj') and node.get('reftarget') == 'None':\n-        return contnode\n-    elif node.get('reftype') in ('class', 'exc'):\n-        reftarget = node.get('reftarget')\n-        if inspect.isclass(getattr(builtins, reftarget, None)):\n-            # built-in class\n-            return contnode\n-        elif istyping(reftarget):\n-            # typing class\n-            return contnode\n-\n-    return None\n-\n+                node += addnodes.desc_sig_operator('', '=')\n+            node += nodes.inline('', default_value, classes=['default_value'],\n+                               support_smartquotes=False)\n \n-def setup(app: Sphinx) -> Dict[str, Any]:\n-    app.setup_extension('sphinx.directives')\n+        params += node\n+        last_kind = param.kind\n \n-    app.add_domain(PythonDomain)\n-    app.connect('object-description-transform', filter_meta_fields)\n-    app.connect('missing-reference', builtin_resolver, priority=900)\n+    if last_kind == Parameter.POSITIONAL_ONLY:\n+        # PEP-570: Separator for Positional Only Parameter: /\n+        params += addnodes.desc_parameter('', '', addnodes.desc_sig_operator('', '/'))\n \n-    return {\n-        'version': 'builtin',\n-        'env_version': 2,\n-        'parallel_read_safe': True,\n-        'parallel_write_safe': True,\n-    }\n+    return params\n\\ No newline at end of file\ndiff --git a/tox.ini b/tox.ini\nindex a61299979..e2baccc07 100644\n--- a/tox.ini\n+++ b/tox.ini\n@@ -28,7 +28,7 @@ setenv =\n     PYTHONWARNINGS = all,ignore::ImportWarning:importlib._bootstrap_external,ignore::DeprecationWarning:site,ignore::DeprecationWarning:distutils\n     PYTEST_ADDOPTS = --color yes\n commands=\n-    pytest --durations 25 {posargs}\n+    pytest -rA --durations 25 {posargs}\n \n [testenv:flake8]\n basepython = python3\ndiff --git a/sphinx/ext/tuple_fix.py b/sphinx/ext/tuple_fix.py\nnew file mode 100644\nindex 000000000..f64a5a9b1\n--- /dev/null\n+++ b/sphinx/ext/tuple_fix.py\n@@ -0,0 +1,46 @@\n+\"\"\"\n+Sphinx extension to fix tuple default argument rendering in docstrings.\n+\"\"\"\n+\n+def format_tuple_default(app, what, name, obj, options, signature, return_annotation):\n+    \"\"\"\n+    Event handler to format tuple default arguments correctly.\n+    \"\"\"\n+    if not signature:\n+        return signature, return_annotation\n+\n+    import re\n+    import ast\n+    from sphinx.util.inspect import signature_from_str\n+\n+    def format_value(val):\n+        if isinstance(val, tuple):\n+            return f\"({', '.join(format_value(x) for x in val)})\"\n+        elif isinstance(val, str):\n+            return f'\"{val}\"'\n+        return str(val)\n+\n+    def replace_tuple(match):\n+        try:\n+            # Extract just the tuple part\n+            tuple_str = match.group(1)\n+            # Parse it as a Python literal using ast for safety\n+            val = ast.literal_eval(f\"({tuple_str})\")\n+            if isinstance(val, tuple):\n+                return f\"=({', '.join(format_value(x) for x in val)})\"\n+            return match.group(0)\n+        except (SyntaxError, ValueError):\n+            return match.group(0)\n+\n+    # Replace tuple defaults with properly formatted versions\n+    signature = re.sub(r'=\\s*\\(([^()]+)\\)', replace_tuple, signature)\n+    return signature, return_annotation\n+\n+\n+def setup(app):\n+    app.connect('autodoc-process-signature', format_tuple_default)\n+    return {\n+        'version': '1.0',\n+        'parallel_read_safe': True,\n+        'parallel_write_safe': True,\n+    }\n\\ No newline at end of file\ndiff --git a/tests/test_ext_tuple_fix.py b/tests/test_ext_tuple_fix.py\nnew file mode 100644\nindex 000000000..005a0f988\n--- /dev/null\n+++ b/tests/test_ext_tuple_fix.py\n@@ -0,0 +1,32 @@\n+\"\"\"\n+Test suite for the tuple_fix extension.\n+\"\"\"\n+\n+from sphinx.application import Sphinx\n+from sphinx.ext.tuple_fix import format_tuple_default\n+\n+\n+def test_format_tuple_default(app):\n+    \"\"\"Test that tuple default arguments are formatted correctly.\"\"\"\n+    test_cases = [\n+        (\n+            'test_func(arg, color=(1, 1, 1))',\n+            'test_func(arg, color=(1, 1, 1))',\n+        ),\n+        (\n+            'test_func(arg, vals=(1, \"test\"))',\n+            'test_func(arg, vals=(1, \"test\"))',\n+        ),\n+        (\n+            'test_func(x, y=(True, False))',\n+            'test_func(x, y=(True, False))',\n+        ),\n+        (\n+            'test_func(x, text=(\"abc\", \"def\"))',\n+            'test_func(x, text=(\"abc\", \"def\"))',\n+        ),\n+    ]\n+\n+    for sig_in, sig_expected in test_cases:\n+        sig_out, _ = format_tuple_default(None, None, None, None, None, sig_in, None)\n+        assert sig_out == sig_expected, f\"Expected {sig_expected}, got {sig_out}\"\n\\ No newline at end of file\n",
    "proposed_model_patches": []
}